算法和数据结构新手班

01 位运算、算法是什么、介绍位运算和简单排序

内容：

讲解二进制、位运算

介绍什么是算法

讲解冒泡、选择、插入排序

题目：

实现打印一个整数的二进制

给定一个参数N，返回1!+2!+3!+4!+…+N!的结果

实现冒泡排序

实现选择排序

实现插入排序



02 数据结构的大分类、介绍前缀和与对数器

内容：

什么是数据结构、组成各种数据结构最基本的元件

前缀和数组

随机函数

对数器的使用

题目：

实现前缀和数组

如何用1~5的随机函数加工出1~7的随机函数

如何用a~b的随机函数加工出c~d的随机函数

展示对数器的使用

如何把不等概率随机函数变成等概率随机函数



03 介绍二分法，介绍时间复杂度、动态数组、哈希表和有序表

内容：

二分法

使用二分法解决不同的题目

时间复杂度

动态数组

按值传递、按引用传递

哈希表

有序表

题目：

有序数组中找到num

有序数组中找到>=num最左的位置

有序数组中找到<=num最右的位置

局部最小值问题

哈希表使用的code讲解

有序表使用的code讲解



04 链表相关的简单面试题

内容：

单双链表的定义

栈、队列

双端队列

题目：

反转单链表

反转双链表

用单链表实现队列

用单链表实现栈

用双链表实现双端队列

K个节点的组内逆序调整问题：
给定一个单链表的头节点head，和一个正数k
实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
例子: 
调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

两个链表相加问题
给定两个链表的头节点head1和head2，
认为从左到右是某个数字从低位到高位，返回相加之后的链表
例子     4 -> 3 -> 6        2 -> 5 -> 3
返回     6 -> 8 -> 9
解释     634 + 352 = 986

两个有序链表的合并
给定两个有序链表的头节点head1和head2，
返回合并之后的大链表，要求依然有序
例子     1 -> 3 -> 3 -> 5 -> 7   2 -> 2 -> 3 -> 3-> 7
返回     1 -> 2 -> 2 -> 3 -> 3 -> 3 -> 3 -> 5 -> 7



05 位图、位运算实现加减乘除

内容：

位图

位运算使用的进一步学习：实现加减乘除

题目：

现场写位图的code、讲解

位运算的加减乘除



06 比较器、优先级队列、二叉树

内容：

比较器

优先级队列

二叉树的基本遍历

二叉树的递归套路

题目：

补充了一个链表的题目
合并多个有序链表
Leetcode原题，https://leetcode.com/problems/merge-k-sorted-lists

判断两颗树是否结构相同
Leetcode原题，https://leetcode.com/problems/same-tree

判断一棵树是否是镜面树
Leetcode原题，https://leetcode.com/problems/symmetric-tree

返回一棵树的最大深度
Leetcode原题，https://leetcode.com/problems/maximum-depth-of-binary-tree

用先序数组和中序数组重建一棵树
Leetcode原题，https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

用code展示比较器的使用

二叉树先序、中序、后序遍历的代码实现、介绍递归序



07 继续二叉树的很多题目

内容：

进一步讲解二叉树题目，来熟悉二叉树

题目：

二叉树按层遍历并收集节点
Leetcode原题，https://leetcode.com/problems/binary-tree-level-order-traversal-ii

判断是否是平衡搜索二叉树
Leetcode原题，https://leetcode.com/problems/balanced-binary-tree

在二叉树上能否组成路径和
Leetcode原题，https://leetcode.com/problems/path-sum

在二叉树上收集所有达标的路径和
Leetcode原题，https://leetcode.com/problems/path-sum-ii

判断二叉树是否是搜索二叉树



08 介绍归并排序和快速排序

内容：

讲解一个位运算的题目

归并排序

快速排序

题目：

不要用任何比较判断，返回两个数中较大的数

归并排序的递归实现和非递归实现

快速排序的递归实现和非递归实现



======================================================================================================================================



算法和数据结构体系学习班

00 算法和数据结构学前必看

内容：

算法和数据结构课程体系介绍

算法和数据结构学习路线

算法和数据结构学习方式推荐

算法和数据结构面试软技巧

同学们的各种答疑问题



01 时间复杂度、空间复杂度、对数器和二分法

内容：

评估算法优劣的核心指标

时间复杂度、空间复杂度、估算方式、意义

常数时间的操作

选择排序、冒泡排序、插入排序

最优解

对数器

二分法

题目：

选择排序及其对数器验证

冒泡排序及其对数器验证

插入排序及其对数器验证

有序数组中找到num

有序数组中找到>=num最左的位置

有序数组中找到<=num最右的位置

局部最小值问题
定义何为局部最小值：
arr[0] < arr[1]，0位置是局部最小；
arr[N-1] < arr[N-2]，N-1位置是局部最小；
arr[i-1] > arr[i] < arr[i+1]，i位置是局部最小；
给定一个数组arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回



02 异或运算、进一步认识对数器的重要性

内容：

异或运算的性质

异或运算的题目

题目：

不用额外变量交换两个数的值

不用额外变量交换数组中两个数的值

一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 

怎么把一个int类型的数，提取出二进制中最右侧的1来

一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 

一个数组中有一种数出现K次，其他数都出现了M次，
已知M > 1，K < M，找到出现了K次的数
要求额外空间复杂度O(1)，时间复杂度O(N)



03 单双链表、栈和队列、递归和Master公式、哈希表和有序表的使用和性能

内容：

单链表、双链表

栈、队列

递归的物理实质

评估递归复杂度的Master公式

哈希表的使用和性能

有序表的使用和性能

题目：

反转单链表、反转双链表

在链表中删除指定值的所有节点

用双链表实现栈和队列

用环形数组实现栈和队列

实现有getMin功能的栈

两个栈实现队列

两个队列实现栈

用递归行为得到数组中的最大值，并用master公式来估计时间复杂度

哈希表和有序表使用的code展示



04 归并排序及其常见面试题

内容：

归并排序

题目：

归并排序的递归和非递归实现

在一个数组中，一个数左边比它小的数的总和，叫该数的小和
所有数的小和累加起来，叫数组小和
例子： [1,3,4,2,5] 
1左边比1小的数：没有
3左边比3小的数：1
4左边比4小的数：1、3
2左边比2小的数：1
5左边比5小的数：1、3、4、 2
所以数组的小和为1+1+3+1+1+3+4+2=16 
给定一个数组arr，求数组小和

在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为降序对
给定一个数组arr，求数组的降序对总数量

在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然<num，返回总个数
比如：[3,1,7,0,2]
3的后面有：1，0
1的后面有：0
7的后面有：0，2
0的后面没有
2的后面没有
所以总共有5个



05 归并排序面试题(续)、快速排序

内容：

再来一个归并排序面试题

荷兰国旗问题

快速排序1.0

快速排序2.0

快速排序3.0

题目：

给定一个数组arr，两个整数lower和upper，
返回arr中有多少个子数组的累加和在[lower,upper]范围上
Leetcode题目：https://leetcode.com/problems/count-of-range-sum/

荷兰国旗问题的实现

快速排序从1.0到3.0的实现

快速排序的递归实现和非递归实现

code附加，双向链表进行快速排序的code实现



06 比较器、堆结构、堆排序

内容：

比较器

堆结构

堆排序

建立大根堆的两种方式，从上到下、从下到上，及其复杂度分析

题目：

比较器使用的code展示

堆结构的实现

堆排序的实现

已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k
k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。 



07 和堆有关的面试题、加强堆结构

内容：

线段最大重合问题

加强堆的实现

题目：

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

加强堆的实现、注意点解析

做一个加强堆的题目，给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op
两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
arr= [3,3,1,2,1,2,5…
op = [T,T,T,T,F,T,F…
依次表示：
3用户购买了一件商品
3用户购买了一件商品
1用户购买了一件商品
2用户购买了一件商品
1用户退货了一件商品
2用户购买了一件商品
5用户退货了一件商品…
一对arr[i]和op[i]就代表一个事件：
用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
op[i] == F就代表这个用户退货了一件商品
现在你作为电商平台负责人，你想在每一个事件到来的时候，
都给购买次数最多的前K名用户颁奖。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。
得奖系统的规则：
1，如果某个用户购买商品数为0，但是又发生了退货事件，
     则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3，每次都是最多K个用户得奖，K也为传入的参数
      如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4，得奖系统分为得奖区和候选区，任何用户只要购买数>0，
      一定在这两个区域中的一个
5，购买数最大的前K名用户进入得奖区，
      在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6，如果购买数不足以进入得奖区的用户，进入候选区
7，如果候选区购买数最多的用户，已经足以进入得奖区，
     该用户就会替换得奖区中购买数最少的用户（大于才能替换），
     如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户
     如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
8，候选区和得奖区是两套时间，
     因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有
     从得奖区出来进入候选区的用户，得奖区时间删除，
     进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
     从候选区出来进入得奖区的用户，候选区时间删除，
     进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，
     离开是指彻底离开，哪个区域也不会找到该用户
     如果下次该用户又发生购买行为，产生>0的购买数，
     会再次根据之前规则回到某个区域中，进入区域的时间重记
请遍历arr数组和op数组，遍历每一步输出一个得奖名单
public List<List<Integer>>  topK (int[] arr, boolean[] op, int k)



08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性

内容：

前缀树

计数排序

基数排序

排序算法的稳定性

题目：

前缀树实现

计数排序

基数排序



09 排序算法大总结、链表及其相关面试题

内容：

排序算法总结

排序算法常见的坑

工程上对排序的常见改进

链表面试题的常见技巧

题目：

输入链表头节点，奇数长度返回中点，偶数长度返回上中点
输入链表头节点，奇数长度返回中点，偶数长度返回下中点
输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

给定一个单链表的头节点head，请判断该链表是否为回文结构

给定一个单链表的头节点head，给定一个整数n，将链表按n划分成左边<n、中间==n、右边>n

一种特殊的单链表节点类描述如下 
class Node {
int value; 
Node next; 
Node rand; 
Node(int val) { value = val; } 
} 
rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null
给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制
返回复制的新链表的头节点，要求时间复杂度O(N)，额外空间复杂度O(1) 



10 链表相关面试题（续）、二叉树的常见遍历

内容：

单链表的相交节点系列问题

一种看似高效其实搞笑的节点删除方式

二叉树的中序、先序、后序遍历

题目：

给定两个可能有环也可能无环的单链表，头节点head1和head2
请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交返回null 
要求如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？

二叉树先序、中序、后序的递归遍历和递归序

二叉树先序、中序、后序的非递归遍历



11 二叉树常见面试题和二叉树的递归套路（上）

内容：

通过题目来熟悉二叉树的解题技巧

题目：

二叉树的按层遍历

二叉树的序列化和反序列化

N叉树如何通过二叉树来序列化、并完成反序列化
Leetcode题目：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/

打印二叉树的函数设计

求二叉树的最大宽度

求二叉树某个节点的后继节点
二叉树结构如下定义：
Class Node {
	V value;
	Node left;
	Node right;
	Node parent;
}
给你二叉树中的某个节点，返回该节点的后继节点 

折纸问题
请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开
此时折痕是凹下去的，即折痕突起的方向指向纸条的背面
如果从纸条的下边向上方连续对折2次，压出折痕后展开
此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 
给定一个输入参数N，代表纸条都从下边向上方连续对折N次
请从上到下打印所有折痕的方向。 
N=1时，打印: down 
N=2时，打印: down down up 



12 二叉树常见面试题和二叉树的递归套路（中）

内容：

通过题目来熟悉二叉树的解题技巧

介绍二叉树的递归套路
1）假设以X节点为头，假设可以向X左树和X右树要任何信息
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

题目：

判断二叉树是不是搜索二叉树

判断二叉树是不是平衡二叉树

判断二叉树是不是满二叉树

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小

给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离



13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法

内容：

二叉树递归套路继续实践

一道贪心算法从头到尾的完整做法

解决贪心题目的重要技巧，即对数器来验证脑洞

再次强调对数器的重要性

题目：

判断二叉树是不是完全二叉树（一般方法解决、递归套路解决）

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点

给定一棵二叉树的头节点head，和另外两个节点a和b，返回a和b的最低公共祖先

派对的最大快乐值
 员工信息的定义如下:
class Employee {
    public int happy; // 这名员工可以带来的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树
树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级
叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外每个员工都有一个或多个直接下级
这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
1.如果某个员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中字典序最小的结果



14 贪心算法（续）、并查集

内容：

贪心算法继续实战

并查集详解

题目：

给定一个字符串str，只由'X'和'.'两种字符构成
'X'表示墙，不能放灯，也不需要点亮；'.'表示居民点，可以放灯，需要点亮
如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮
返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

一块金条切成两半，是需要花费和长度数值一样的铜板
比如长度为20的金条，不管怎么切都要花费20个铜板，一群人想整分整块金条，怎么分最省铜板? 
例如，给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。
如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板
但如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20，花费30；一共花费90铜板
输入一个数组，返回分割的最小代价

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间
你来安排宣讲的日程，要求会议室进行的宣讲的场次最多，返回最多的宣讲场次

输入正数数组costs、正数数组profits、正数K和正数M
costs[i]表示i号项目的花费
profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)
K表示你只能串行的最多做k个项目
M表示你初始的资金
说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目。
输出：最后获得的最大钱数

并查集的实现



15 并查集相关的常见面试题

内容：

通过解答实际出现的面试题来体会并查集的优势、熟悉并查集的使用

题目：

一群朋友中，有几个不相交的朋友圈
Leetcode题目：https://leetcode.com/problems/friend-circles/

岛问题（递归解法 + 并查集解法 + 并行解法）
给定一个二维数组matrix，里面的值不是1就是0，上、下、左、右相邻的1认为是一片岛，返回matrix中岛的数量



16 图及其与图相关的算法

内容：

图的表达方式

图的常见描述

图的宽度优先遍历

图的深度优先遍历

图的拓扑排序

最小生成树算法Kruskal

最小生成树算法Prim

单元最短路径算法Dijkstra

题目：

图的数据结构抽象

实现图的宽度优先遍历

实现图的深度优先遍历

三种方式实现图的拓扑排序

用并查集实现Kruskal算法

用堆实现Prim算法

实现Dijkstra算法，用加强堆做更好的实现（16节+17节一开始）



17 用加强堆更好的实现Dijkstra算法、常见的递归

内容：

加强堆实现Dijkstra算法

递归的设计

常见的递归

题目：

打印n层汉诺塔从最左边移动到最右边的全部过程（递归+非递归实现）

打印一个字符串的全部子序列

打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

打印一个字符串的全部排列

打印一个字符串的全部排列，要求不要出现重复的排列

给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数



18 暴力递归到动态规划（一）

内容：

讲述暴力递归和动态规划的关系

记忆化搜索

动态规划都可以由暴力递归改进过来，解决动态规划的套路

常见的尝试模型

设计尝试过程的原则

本节是暴力递归到动态规划的总纲（很重要）

后续的课都是在讲述这一系列的套路

题目：

假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的M位置上(M一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数

给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数



19 暴力递归到动态规划（二）

内容：

以18节为总纲

背包问题

记忆化搜索的一个很重要的注意点

通过面试题进一步强化动态规划的解题套路

题目：

背包问题
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2

给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6



20 暴力递归到动态规划（三）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7

请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 

给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b



21 暴力递归到动态规划（四）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和
返回最小距离累加和

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
即便是值相同的货币也认为每一张都是不同的，
返回组成aim的方法数
例如：arr = {1,1,1}，aim = 2
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
一共就3种方法，所以返回3

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的方法数
例如：arr = {1,2}，aim = 4
方法如下：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
认为值相同的货币没有任何不同，
返回组成aim的方法数
例如：arr = {1,2,1,1,2,1,2}，aim = 4
方法：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

给定5个参数，N，M，row，col，k
表示在N*M的区域上，醉汉Bob初始在(row,col)位置
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
任何时候Bob只要离开N*M的区域，就直接死亡
返回k步之后，Bob还在N*M的区域的概率



22 暴力递归到动态规划（五）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

斜率优化技巧

题目：

给定3个参数，N，M，K
怪兽有N滴血，等着英雄来砍自己
英雄每一次打击，都会让怪兽流失[0~M]的血量
到底流失多少？每一次在[0~M]上等概率的获得一个值
求K次打击之后，英雄把怪兽砍死的概率

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的最少货币数

给定一个正数n，求n的裂开方法数，
规定：后面的数不能比前面的数小
比如4的裂开方法有：
1+1+1+1、1+1+2、1+3、2+2、4
5种，所以返回5



23 暴力递归到动态规划（六）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

位信息技巧

题目：

给定一个正数数组arr，
请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

给定一个正数数组arr，请把arr中所有的数分成两个集合
如果arr长度为偶数，两个集合包含数的个数要一样多
如果arr长度为奇数，两个集合包含数的个数必须只差一个
请尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

N皇后问题是指在N*N的棋盘上要摆N个皇后，
要求任何两个皇后不同行、不同列， 也不在同一条斜线上
给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92



24 窗口内最大值或最小值的更新结构

内容：

滑动窗口

窗口内最大值或最小值的更新结构

用题目来学习窗口内最大值或最小值的更新结构提供的便利性

题目：

窗口内最大值或最小值更新结构的实现
假设一个固定大小为W的窗口，依次划过arr，
返回每一次滑出状况的最大值
例如，arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]

给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量

加油站的良好出发点问题

动态规划中利用窗口内最大值或最小值更新结构做优化（难）
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
返回组成aim的最少货币数
注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了



25 单调栈

内容：

单调栈的原理（无重复数+有重复数）

用题目来学习单调栈提供的便利性

题目：

单调栈实现（无重复数+有重复数）

给定一个只包含正数的数组arr，arr中任何一个子数组sub，
一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？

给定一个非负数组arr，代表直方图，返回直方图的最大长方形面积

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量



26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型

内容：

再讲一个单调栈相关的面试题

斐波那契数列的矩阵快速幂模型详解

题目：

给定一个数组arr，返回所有子数组最小值的累加和

斐波那契数列矩阵乘法方式的实现

台阶方法数问题
一个人可以一次往上迈1个台阶，也可以迈2个台阶，返回迈上N级台阶的方法数

奶牛生小牛问题
第一年农场有1只成熟的母牛A，往后的每年：
1）每一只成熟的母牛都会生一只母牛
2）每一只新出生的母牛都在出生的第三年成熟
3）每一只母牛永远不会死
返回N年后牛的数量

给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串
如果某个字符串，任何0字符的左边都有1紧挨着，认为这个字符串达标
返回有多少达标的字符串

用1*2的瓷砖，把N*2的区域填满，返回铺瓷砖的方法数



27 KMP算法

内容：

KMP算法

和KMP算法相关的面试题

题目：

KMP算法实现

给定两棵二叉树的头节点head1和head2，返回head1中是否有某个子树的结构和head2完全一样

判断str1和str2是否互为旋转字符串



28 Manacher算法

内容：

Manacher算法

和Manacher算法相关的面试题

题目：

Manacher算法实现

给定一个字符串str，只能在str的后面添加字符，想让str整体变成回文串，返回至少要添加几个字符



29 在无序数组中找到第K小的数、蓄水池算法

内容：

时间复杂度O(N)可以解决在无序数组中找到第K小的数，这个经典的面试题

改写快排的partition方法

bfprt算法

蓄水池算法

题目：

在无序数组中找到第K小的数（改写快排+bfprt）

设计在无序数组中收集最大的前K个数字的算法（根据不同的三个时间复杂度，设计三个算法）
给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：
1）O(N*logN)
2）O(N + K*logN)
3）O(n + k*logk)

蓄水池算法实现
假设有一个源源吐出不同球的机器，
只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉
如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里




30 二叉树的Morris遍历

内容：

二叉树之前的遍历方式有空间浪费的问题

Morris遍历时间复杂度O(N)，额外空间复杂度O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的

假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，
	然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，
	然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

Morris遍历实现二叉树的先序、中序、后序遍历

题目：

Morris遍历的实现

给定一棵二叉树的头节点head，求以head为头的树中，最小深度是多少？



31 线段树

内容：

线段树是一种支持范围整体修改和范围整体查询的数据结构

线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况

题目：

给定一个数组arr，用户希望你实现如下三个方法
1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
怎么让这三个方法，时间复杂度都是O(logN)

想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线
下面是这个游戏的简化版：
1）只会下落正方形积木
2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落
3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的
4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。
给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，
返回每一次掉落之后的最大高度
Leetcode题目：https://leetcode.com/problems/falling-squares/



32 IndexTree、AC自动机

内容：

IndexTree
1）支持区间查询
2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构
3）只支持单点更新

AC自动机
解决在一个大字符串中，找到多个候选字符串的问题
1）把所有匹配串生成一棵前缀树
2）前缀树节点增加fail指针
3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀
   拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点（迷不迷？听讲述！）

题目：

IndexTree在一维数组和二维数组上的实现

AC自动机的实现



33 与哈希函数有关的结构

内容：

哈希函数

哈希函数的应用

布隆过滤器

一致性哈希

题目：

原理讲述为主，面试只会聊设计，所以本节无题目



34 资源限制类题目的解题套路

内容：

布隆过滤器用于集合的建立与查询，并可以节省大量空间
一致性哈希解决数据服务器的负载管理问题
利用并查集结构做岛问题的并行计算
哈希函数可以把数据按照种类均匀分流
位图解决某一范围上数字的出现情况，并可以节省大量空间
利用分段统计思想、并进一步节省大量空间
利用堆、外排序来做多个处理单元的结果合并

题目：

32位无符号整数的范围是0~4,294,967,295，
现在有一个正好包含40亿个无符号整数的文件，
可以使用最多1GB的内存，怎么找到出现次数最多的数？

32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，
所以在整个范围中必然存在没出现过的数，可以使用最多1GB的内存，怎么找到所有未出现过的数？
进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可

有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？

32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果



35 有序表（上）

内容：

平衡搜索二叉树

左旋

右旋

AVL树的节点违规4种类型（LL，LR，RL，RR）

题目：

AVL树的实现



36 有序表（中）

内容：

size-balanced-tree详解

skiplist详解

聊聊红黑树

题目：

size-balanced-tree实现

skiplist实现



37 有序表（下）

内容：

讲解有序表相关的面试题

讲解改写有序表的题目核心点

题目：

给定一个数组arr，和两个整数a和b（a<=b）。求arr中有多少个子数组，累加和在[a,b]这个范围上。返回达标的子数组数量

有一个滑动窗口：
1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口
想知道每一个窗口状态的中位数

设计一个结构包含如下两个方法：
void add(int index, int num)：把num加入到index位置
int get(int index) ：取出index位置的值
void remove(int index) ：把index位置上的值删除
要求三个方法时间复杂度O(logN)

假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）
每个people[i]=[hi, ki]表示第i个人的身高为hi，前面正好有ki个身高大于或等于hi的人
请你重新构造并返回输入数组people所表示的队列，返回的队列应该格式化为数组queue
其中queue[j]=[hj, kj]是队列中第j个人的属性（queue[0] 是排在队列前面的人）。
Leetcode题目：https://leetcode.com/problems/queue-reconstruction-by-height/



38 根据对数器找规律、根据数据量猜解法

内容：

讲解对数器找规律的解题技巧

讲解根据数据量猜解法的技巧
1）C/C++，1秒处理的指令条数为10的8次方
2）Java等语言，1~4秒处理的指令条数为10的8次方
3）这里就有大量的分析提示了


题目：

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，
且使用的每个袋子必须装满，给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草
不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方)
谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数N，返回谁会赢

定义一种数：可以表示成若干（数量>1）连续正数和的数
比如，5=2+3，5就是这样的数；12=3+4+5，12就是这样的数
2=1+1，2不是这样的数，因为等号右边不是连续正数
给定一个参数N，返回是不是可以表示成若干连续正数和的数

int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力
你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上
返回通过所有的怪兽，需要花的最小钱数
（课上会给出不同的数据量描述）



39 根据数据量猜解法（续）、分治技巧、卡特兰数

内容：

继续熟悉根据数据量猜解法

讲解分治法

讲解卡特兰数（课上证明的时候有小错，在40节开始处修正了）

题目：

给定一个非负数组arr，和一个正数m，返回arr的所有子序列中累加和%m之后的最大值

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w，牛牛想知道在总体积不超过背包容量的情况下,
一共有多少种零食放法，体积为0也算一种放法
1 <= n <= 30, 1 <= w <= 2 * 10^9，v[I] (0 <= v[i] <= 10^9）

假设给你N个0，和N个1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1的数量都不少于0的数量

有N个二叉树节点，每个节点彼此之间无任何差别，返回由N个二叉树节点，组成的不同结构数量是多少？

题目补充：	arr中的值可能为正，可能为负，可能为0，自由选择arr中的数字，能不能累加得到sum（多种做法）



40 子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题

内容：

修正了39节卡特兰数讲解时的一个小错误

熟悉子数组达到规定累加和的三个模型（正、有正有负有0、累加和<=K）

矩阵处理技巧的宏观调度coding技巧

题目：

给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K
并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

给定一个正方形矩阵matrix，原地调整成顺时针90度转动的样子

给定一个正方形或者长方形矩阵matrix，实现转圈打印

给定一个正方形或者长方形矩阵matrix，实现zigzag打印

转圈打印星号*问题



41 四边形不等式技巧（上）

内容：

区间划分问题中的划分点不回退现象

四边形不等式技巧特征
1，两个可变参数的区间划分问题
2，每个格子有枚举行为
3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
4，而且两组单调关系是反向的：(升 升，降 降)  (升 降，降 升)
5，能否获得指导枚举优化的位置对：上+右，或者，左+下

四边形不等式技巧注意点
1，不要证明！用对数器验证！
2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！
3，可以把时间复杂度降低一阶
O(N^3) -> O(N^2)
O(N^2 * M) -> O(N * M) 
O(N * M^2) -> O(N * M) 
4，四边形不等式有些时候是最优解，有些时候不是
不是的原因：尝试思路，在根儿上不够好

题目：

给定一个非负数组arr，长度为N，
那么有N-1种方案可以把arr切成左右两部分
每一种方案都有，min{左部分累加和，右部分累加和}
求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？
整个过程要求时间复杂度O(N)

把题目一中提到的，min{左部分累加和，右部分累加和}，定义为S(N-1)，也就是说：
S(N-1)：在arr[0…N-1]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
现在要求返回一个长度为N的s数组，
s[i] =在arr[0…i]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
得到整个s数组的过程，做到时间复杂度O(N)

摆放着n堆石子。现要将石子有次序地合并成一堆，规定每次只能选相邻的2堆石子合并成新的一堆
并将新的一堆石子数记为该次合并的得分，求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案

给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num
表示画匠的数量，每个画匠只能画连在一起的画作
所有的画家并行工作，返回完成所有的画作需要的最少时间
arr=[3,1,4]，num=2。
最好的分配方式为第一个画匠画3和1，所需时间为4
第二个画匠画4，所需时间为4
所以返回4
arr=[1,1,1,4,3]，num=3
最好的分配方式为第一个画匠画前三个1，所需时间为3
第二个画匠画4，所需时间为4
第三个画匠画3，所需时间为3
返回4



42 四边形不等式技巧（下）

内容：

继续熟悉四边形不等式

展示好的尝试是最关键的

题目：

一条直线上有居民点，邮局只能建在居民点上
给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量
选择num个居民点建立num个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离
arr=[1,2,3,4,5,1000]，num=2
第一个邮局建立在3位置，第二个邮局建立在1000位置
那么1位置到邮局的距离为2，2位置到邮局距离为1，3位置到邮局的距离为0，4位置到邮局的距离为1，5位置到邮局的距离为2
1000位置到邮局的距离为0
这种方案下的总距离为6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回6

一座大楼有0~N层，地面算作第0层，最高的一层为第N层
已知棋子从第0层掉落肯定不会摔碎，从第i层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)
给定整数N作为楼层数，再给定整数K作为棋子数
返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数
一次只能扔一个棋子
N=10，K=1
返回10
因为只有1棵棋子，所以不得不从第1层开始一直试到第10层
在最差的情况下，即第10层是不会摔坏的最高层，最少也要扔10次
N=3，K=2
返回2
先在2层扔1棵棋子，如果碎了试第1层，如果没碎试第3层
N=105，K=2
返回14
第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13
若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26
若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38
若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49
若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59
若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68
若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76
若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83
若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89
若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94
若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98
若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101
若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103
若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果



43 状态压缩的动态规划

内容：

动态规划的状态压缩技巧

题目：

在"100 game"这个游戏中，两名玩家轮流选择从1到10的任意整数，累计整数和
先使得累计整数和达到或超过100的玩家，即为胜者，如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？
例如，两个玩家可以轮流从公共整数池中抽取从1到15的整数（不放回），直到累计整数和 >= 100
给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和）
判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）
你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。
Leetcode题目：https://leetcode.com/problems/can-i-win/

TSP问题
有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0
所有点到点的距离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示
现要求一旅行商从k城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城
参数给定一个matrix，给定k。返回总距离最短的路的距离

铺砖问题（最优解其实是轮廓线dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）
你有无限的1*2的砖块，要铺满M*N的区域，
不同的铺法有多少种?



44 DC3生成后缀数组详解

内容：

后缀数组

介绍用DC3算法生成后缀数组的流程

题目：

给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串
Leetcode题目：https://leetcode.com/problems/last-substring-in-lexicographical-order/

DC3算法的实现（完全根据论文描述）



45 后缀数组解决的面试题

内容：

通过题目进一步熟悉DC3算法

通过DC3算法得到height数组

题目：

给定两个字符串str1和str2，想把str2整体插入到str1中的某个位置，形成最大的字典序，返回字典序最大的结果

给两个长度分别为M和N的整型数组nums1和nums2，其中每个值都不大于9，再给定一个正数K。 你可以在nums1和nums2中挑选数字，要求一共挑选K个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果

最长公共子串问题是面试常见题目之一，假设str1长度N，str2长度M
一般在面试场上回答出O(N*M)的解法已经是比较优秀了
因为得到O(N*M)的解法，就已经需要用到动态规划了
但其实这个问题的最优解是O(N+M)，需要用到后缀数组+height数组
课上将对本题解法代码进行详解



46 动态规划猜法中和外部信息简化的相关问题（上）、哈夫曼树

内容：

以18节做总纲

有些动态规划面试题，需要很好的设计参数，这种设计方式都有"外部信息简化"的特征

哈夫曼树

题目：

有n个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中
现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1] 枚硬币
这里的i-1和i+1代表和i相邻的、没有被戳爆的！两个气球的序号
如果i-1或i+1超出了数组的边界，那么就当它是一个数字为1的气球
求所能获得硬币的最大数量
Leetcode题目：https://leetcode.com/problems/burst-balloons/

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子
直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续k个盒子（k >= 1）
这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和
Leetcode题目：https://leetcode.com/problems/remove-boxes/

如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉
比如:"ab"，其中a和b都不能被消掉
如果一个字符相邻的位置有相同字符，就可以一起消掉
比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac"
某些字符如果消掉了，剩下的字符认为重新靠在一起
给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量
比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1
但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。
再比如："baaccabb"，
如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，最后消除最右侧的两个b，剩下"ba"无法再消除，返回2
而最优策略是：
如果先消除中间的两个c，剩下"baaabb"，如果再消除中间的三个a，剩下"bbb"，最后消除三个b，不留下任何字符，返回0，这才是最优解

给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和

哈夫曼树的实现



47 动态规划猜法中和外部信息简化的相关问题（下）、最大网络流算法之Dinic算法

内容：

进一步解决带有"外部信息简化"特征的动态规划

Dinic算法

题目：

有台奇怪的打印机有以下两个特殊要求：
打印机每次只能打印由同一个字符组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串s，你的任务是计算这个打印机打印它需要的最少打印次数。
Leetcode题目：https://leetcode.com/problems/strange-printer/

整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件：
1. 0位置的要求：arr[0]<=arr[1] 
2. n-1位置的要求：arr[n-1]<=arr[n-2]
3. 中间i位置的要求：arr[i]<=max(arr[i-1],arr[i+1]) 
但是在arr有些数字丢失了，比如k位置的数字之前是正数，丢失之后k位置的数字为0
请你根据上述条件，计算可能有多少种不同的arr可以满足以上条件
比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1，即[6,9,9]达标

Dinic算法详解
测试链接：https://lightoj.com/problem/internet-bandwidth



======================================================================================================================================



01 大厂高频算法和数据结构面试题1

题目：

给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？
即使绳子边缘处盖住点也算盖住

给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算

给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方

一个数组中只有两种字符'G'和'B'，可以让所有的G都放在左侧，所有的B都放在右侧
或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在相邻字符之间进行交换操作，返回至少需要交换几次

给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，返回能走出来的最长的递增链长度

给定两个非负数组x和hp，长度都是N，再给定一个正数range
x有序，x[i]表示i号怪兽在x轴上的位置
hp[i]表示i号怪兽的血量
再给定一个正数range，表示如果法师释放技能的范围长度
被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target
请问最后算出target的方法数



02 大厂高频算法和数据结构面试题2

题目：

给定数组hard和money，长度都为N，hard[i]表示i号工作的难度， money[i]表示i号工作的收入
给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样
但是人的能力必须>=这份工作的难度，才能上班。返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入

贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额
一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则
需要购买的可乐数量是m，其中手头拥有的10、50、100的数量分别为a、b、c，可乐的价格是x(x是10的倍数)
请计算出需要投入硬币次数

已知一个消息流会不断地吐出整数1~N，但不一定按照顺序依次吐出，如果上次打印的序号为i， 那么当i+1出现时
请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构

现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为income[i][0]，去B可得收入为income[i][1]
返回能使所有司机总收入最高的方案是多少钱?

设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)

给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序，返回满足这一设定的子数组中最短的是多长



03 大厂高频算法和数据结构面试题3

题目：

求一个字符串中，最长无重复字符子串长度

只由小写字母（a~z）组成的一批字符串，都放在字符类型的数组String[] arr中，如果其中某两个字符串所含有的字符种类完全一样
就将两个字符串算作一类，比如baacbba和bac就算作一类，返回arr中有多少类

给定一个只有0和1组成的二维数组，返回边框全是1（内部无所谓）的最大正方形面积

给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛
一局比赛只有两个人，返回最多可以同时有多少场比赛

给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重
想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数

给定整数数组nums和目标值goal，需要从nums中选出一个子序列，使子序列元素总和最接近goal
也就是说如果子序列元素和为sum ，需要最小化绝对差abs(sum - goal)，返回 abs(sum - goal)可能的最小值
注意数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。

电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门
给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数
最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符
旋转 ring 拼出 key 字符 key[i] 的阶段中：
您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
Leetcode题目：https://leetcode.com/problems/freedom-trail/

给定三个参数，二叉树的头节点head，树上某个节点target，正数K。从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点



04 大厂高频算法和数据结构面试题4

题目：

数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个？答案返回2
假设给你一个数组arr，对这个数组的查询非常频繁，且都给了查询组，请返回所有查询的结果

返回一个数组中子数组最大累加和

返回一个二维数组中子矩阵最大累加和

返回一个数组中所选数字不能相邻的情况下最大子序列累加和

老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，返回老师至少需要准备多少颗糖果
进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果

生成长度为size的达标数组，什么叫达标？对于任意的i<k<j，满足[i]+[j]!=[k]*2。给定一个正数size，返回长度为size的达标数组

给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的
Leetcode题目：https://leetcode.com/problems/interleaving-string/

大楼轮廓线问题
Leetcode题目：https://leetcode.com/problems/the-skyline-problem/



05 大厂高频算法和数据结构面试题5

题目：

已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点

如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树

编辑距离问题

给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = "abcde"，s2 = "axbc"，s2删掉'x'即可，返回1



06 大厂高频算法和数据结构面试题6

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，返回arr的最大子数组异或和

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，想知道arr中哪两个数的异或结果最大，返回最大的异或结果
Leetcode题目：https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/

给定一个非负整数组成的数组nums。另有一个查询数组queries，其中queries[i]=[xi, mi]
第i个查询的答案是xi和任何nums数组中不超过mi的元素按位异或（XOR）得到的最大值
换句话说，答案是max(nums[j] XOR xi)，其中所有j均满足nums[j]<= mi。如果nums中的所有元素都大于mi，最终答案就是-1
返回一个整数数组answer作为查询的答案，其中answer.length==queries.length且answer[i]是第i个查询的答案
Leetcode题目：https://leetcode.com/problems/maximum-xor-with-an-element-from-array/

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，可以任意切分成若干个不相交的子数组。其中一定存在一种最优方案，使得切出异或和为0的子数组最多，返回这个最多数量

Nim博弈，给定一个正数数组arr，先手和后手每次可以选择在一个位置拿走若干值，这个值要大于0，但是要小于该处的剩余，谁最先拿空arr谁赢，根据arr返回谁赢



07 大厂高频算法和数据结构面试题7

给定一个非负数组成的数组，长度一定大于1，想知道数组中哪两个数&的结果最大，返回这个最大结果。要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个二叉树，我们在树的节点上安装摄像头，节点上的每个摄影头都可以监视其父对象、自身及其直接子对象，计算监控树的所有节点所需的最小摄像头数量

给定一个数组arr，返回如果排序之后（注意是如果排序），相邻两数的最大差值。要求时间复杂度O(N)，不能使用非基于比较的排序

给定一个有序数组arr，其中值可能为正、负、0。返回arr中每个数都平方之后不同的结果有多少种？
给定一个数组arr，先递减然后递增，返回arr中有多少个不同的数字？

假设所有字符都是小写字母，大字符串是str，arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次。使用arr中的单词有多少种拼接str的方式，返回方法数。

String str, int K, String[] parts, int[] record
Parts和records的长度一样长，str一定要分割成k个部分，分割出来的每部分在parts里必须得有，那一部分的得分在record里，请问str切成k个部分，返回最大得分



08 大厂高频算法和数据结构面试题8

给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号。返回公式的计算结果
难点在于括号可能嵌套很多层，str="48*((70-65)-43)+8*1"，返回-1816。str="3+1*4"，返回7。str="3+(1*4)"，返回7。
1，可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查
2，如果是负数，就需要用括号括起来，比如"4*(-3)"但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的
3，不用考虑计算过程中会发生溢出的情况。

给定n个非负整数a1，a2，...an，每个数代表坐标中的一个点 (i, ai)。在坐标内画n条垂直线
垂直线i的两个端点分别为(i, ai)和(i, 0)，找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水
Leetcode题目：https://leetcode.com/problems/container-with-most-water/

给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，
可以从任何一个某个位置出发，可以走上、下、左、右，能不能找到word？
 char[][] m = {  { 'a', 'b', 'z' }, 
                 { 'c', 'd', 'o' }, 
                 { 'f', 'e', 'o' } }
设定1：可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是可以找到的，z -> o -> o -> o -> z，因为允许走一条路径中已经走过的字符
设定2：不可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走 

给定一个矩阵matrix，值有正、负、0。蛇可以空降到最左列的任何一个位置，初始增长值是0。蛇每一步可以选择右上、右、右下三个方向的任何一个前进
沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去。蛇有一种能力，可以使用一次：把某个格子里的数变成相反数
蛇可以走到任何格子的时候停止，返回蛇能获得的最大增长值



09 大厂高频算法和数据结构面试题9

题目：

给定一个数组arr，长度为N，arr中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯
每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态
问题一：如果N栈灯排成一条直线,请问最少按下多少次开关？
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关只能影响0和1位置的灯
N-1号灯的开关只能影响N-2和N-1位置的灯
问题二：如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关能影响N-1、0和1位置的灯
N-1号灯的开关能影响N-2、N-1和0位置的灯

给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按任意顺序返回
Leetcode题目：https://leetcode.com/problems/remove-invalid-parentheses/

给定一个数组arr，求最长递增子序列长度
Leetcode题目：https://leetcode.com/problems/longest-increasing-subsequence

给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）
注意：不允许旋转信封

定义何为step sum？比如680，680 + 68 + 6 = 754，680的step sum叫754。给定一个正数num，判断它是不是某个数的step sum



10 大厂高频算法和数据结构面试题10

题目：

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

Top K Frequent Words II
Implement three methods for Topk Class:
TopK(k). The constructor.
add(word). Add a new word.
topk(). Get the current top k frequent words.
LintCode题目：https://www.lintcode.com/problem/550/

给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数
逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对，否则不是
由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值
Leetcode题目：https://leetcode.com/problems/k-inverse-pairs-array/

给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表（节点都有两个方向的指针）

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。
Leetcode题目：https://leetcode-cn.com/problems/boolean-evaluation-lcci/



11 大厂高频算法和数据结构面试题11

题目：

问题一：一个字符串至少需要添加多少个字符能整体变成回文串
问题二：返回问题一的其中一种添加结果
问题三：返回问题一的所有添加结果

问题一：一个字符串至少要切几刀能让切出来的子串都是回文串
问题二：返回问题一的其中一种划分结果
问题三：返回问题一的所有划分结果



12 大厂高频算法和数据结构面试题12

题目：

给定长度为m的字符串aim，以及一个长度为n的字符串str，问能否在str中找到一个长度为m的连续子串，
使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数
进阶，在两个都有序的数组中找整体第K小的数，可以做到O(log(Min(M,N)))

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
返回p能否匹配s



13 大厂高频算法和数据结构面试题13

题目：

谷歌面试题扩展版，面值为1~N的牌组成一组，每次你从组里等概率的抽出1~N中的一张，下次抽会换一个新的组，有无限组
当累加和<a时，你将一直抽牌；当累加和>=a且<b时，你将获胜；当累加和>=b时，你将失败
返回获胜的概率，给定的参数为N，a，b

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的
在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机
给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数
如果不能使每台洗衣机中衣物的数量相等，则返回-1
Leetcode题目：https://leetcode.com/problems/super-washing-machines/

旋变字符串
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
Leetcode题目：https://leetcode.com/problems/scramble-string/

有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：
一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块稳定不会掉落时
给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失
然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）
返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目
注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
Leetcode题目：https://leetcode.com/problems/bricks-falling-when-hit/



14 大厂高频算法和数据结构面试题14

题目：

给定一个只由左括号和右括号的字符串，返回最长的有效括号子串的长度

arr中求子数组的累加和是<=K的并且是最大的，返回这个最大的累加和

从二叉树的某个节点x开始，往下子节点都要的，叫子树；在二叉树上只要能连起来的任何结构，叫子拓扑结构；
返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数

给定一个棵完全二叉树，返回这棵树的节点个数，要求时间复杂度小于O(树的节点数)

给定一个棵搜索二叉树的头节点head，其中有两个节点错了，交换过来就能让整棵树重新变成搜索二叉树，怎么找到并调整正确？
Leetcode题目：https://leetcode.com/problems/recover-binary-search-tree/

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 


15 大厂高频算法和数据结构面试题15

题目：股票系列问题

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/



16 大厂高频算法和数据结构面试题16

题目：

给定一个有正、有负、有0的数组arr，
给定一个整数k，
返回arr的子集是否能累加出k
1）正常怎么做？
2）如果arr中的数值很大，但是arr的长度不大，怎么做？

给定一个正数数组arr，
返回arr的子集不能累加出的最小正数
1）正常怎么做？
2）如果arr中肯定有1这个值，怎么做？

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，
使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示，请输出满足上述要求的最少需要补充的数字个数

给定整数power，给定一个数组arr，给定一个数组reverse。含义如下：
arr的长度一定是2的power次方，reverse中的每个值一定都在0~power范围。
例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}
任何一个在前的数字可以和任何一个在后的数组，构成一对数。可能是升序关系、相等关系或者降序关系。
比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个。
接下来根据reverse对arr进行调整：
reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对。
reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对
reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对。
reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有4个逆序对。
所以返回[3,1,1,4]，表示每次调整之后的逆序对数量。
输入数据状况：
power的范围[0,20]
arr长度范围[1,10的7次方]
reverse长度范围[1,10的6次方]

约瑟夫环问题
给定一个链表头节点head，和一个正数m，从头开始，每次数到m就杀死当前节点，然后被杀节点的下一个节点从1开始重新数，周而复始直到只剩一个节点，返回最后的节点
Leetcode题目：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/



17 大厂高频算法和数据结构面试题17

题目：

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个数num，返回二维数组中有没有num这个数

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个正数k，返回二维数组中第k小的数
Leetcode题目：https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/

给定一个字符串数组arr，里面都是互不相同的单词，找出所有不同的索引对(i, j)，使得列表中的两个单词，words[i] + words[j]，可拼接成回文串。
Leetcode题目：https://leetcode.com/problems/palindrome-pairs/

给定两个字符串S和T，返回S的所有子序列中有多少个子序列的字面值等于T

给定一个字符串str，返回str的所有子序列中有多少不同的字面值
Leetcode题目：https://leetcode.com/problems/distinct-subsequences-ii/



18 大厂高频算法和数据结构面试题18

题目：

给定一个数组arr，长度为N，arr中的值只有1，2，3三种
arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左
arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中
arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右
那么arr整体就代表汉诺塔游戏过程中的一个状况，如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1
如果这个状况是汉诺塔最优解运动过程中的状态，返回它是第几个状态

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
返回必须翻转的 0 的最小数目。（可以保证答案至少是1）
Leetcode题目：https://leetcode.com/problems/shortest-bridge/

给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
输入描述:
第一行输入两个整数M和N，M,N<=200
接下来M行，每行N个整数，表示矩阵中元素
输出描述:
输出一个整数，表示最大路径和
牛客网题目：https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组，按照降序输出
时间复杂度为O(klogk)
输入描述：
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
输出描述：
输出K个整数表示答案
牛客网题目：https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1



19 大厂高频算法和数据结构面试题19

题目：

LRU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lru-cache/

LFU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lfu-cache/

给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：
1 2 3 4 5 6 7 8 9 10 11 12 13
可以数出1这个字符出现了6次，给定一个正数N，如果把1~N都列出来，返回1这个字符出现的多少次

你有k个非递减排列的整数列表。找到一个最小区间，使得k个列表中的每个列表至少有一个数包含在其中
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

一张扑克有3个属性，每种属性有3种值（A、B、C）
比如"AAA"，第一个属性值A，第二个属性值A，第三个属性值A
比如"BCA"，第一个属性值B，第二个属性值C，第三个属性值A
给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克
从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样
挑选的三张扑克达标的要求是：每种属性都满足上面的条件
比如："ABC"、"CBC"、"BBC"
第一张第一个属性为"A"、第二张第一个属性为"C"、第三张第一个属性为"B"，全不一样
第一张第二个属性为"B"、第二张第二个属性为"B"、第三张第二个属性为"B"，全一样
第一张第三个属性为"C"、第二张第三个属性为"C"、第三张第三个属性为"C"，全一样
每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标
返回在cards[]中任意挑选三张扑克，达标的方法数



20 大厂高频算法和数据结构面试题20

题目：

如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，能否不重建树，而直接生成这个二叉树的后序数组并返回，已知二叉树中没有重复值

给定一个由不同正整数的组成的非空数组 A，考虑下面的图：有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；
只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。返回图中最大连通集合的大小
Leetcode题目：https://leetcode.com/problems/largest-component-size-by-common-factor/

完美洗牌问题
给定一个长度为偶数的数组arr，假设长度为N*2
左部分：arr[L1...Ln] 右部分： arr[R1...Rn]
请把arr调整成arr[L1,R1,L2,R2,L3,R3,...,Ln,Rn]
要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个字符串str，当然可以生成很多子序列，返回有多少个子序列是回文子序列，空序列不算回文
比如，str = “aba”，回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}，返回5



21 大厂高频算法和数据结构面试题21

题目：

树链剖分专题
给定数组father，大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
给定数组values，大小为N，values[i]=v表示节点i的权值是v
实现如下4个方法，保证4个方法都很快！
1)让某个子树所有节点值加上v，入参：int head, int v
2)查询某个子树所有节点值的累加和，入参：int head
3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v
4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b



22 大厂高频算法和数据结构面试题22

题目：

给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。每个子数组的长度为k，我们要使这3*k个项的和最大化。返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。
Leetcode题目：https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
Leetcode题目：https://leetcode.com/problems/trapping-rain-water/

给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
Leetcode题目：https://leetcode.com/problems/trapping-rain-water-ii/

一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度
比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山
山峰A和山峰B能够相互看见的条件为: 
1.如果A和B是同一座山，认为不能相互看见
2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见
3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min
       1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
       2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
两个方向只要有一个能看见，就算A和B可以相互看见
给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见
进阶，给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见

你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。
Leetcode题目：https://leetcode.com/problems/tallest-billboard/



23 大厂高频算法和数据结构面试题23

题目：

给定数组father大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
queries是二维数组，大小为M*2，每一个长度为2的数组都表示一条查询
[4,9], 表示想查询4和9之间的最低公共祖先… 
[3,7], 表示想查询3和7之间的最低公共祖先…
tree和queries里面的所有值，都一定在0~N-1之间
返回一个数组ans，大小为M，ans[i]表示第i条查询的答案

给定一个数组arr，长度为N > 1，从中间切一刀，保证左部分和右部分都有数字，一共有N-1种切法
如此多的切法中，每一种都有:绝对值(左部分最大值 – 右部分最大值)，返回最大的绝对值是多少

定义什么是可整合数组：一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1
则称这个数组为可整合数组比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组，返回arr中最长可整合子数组的长度

超级水王问题
给定一个数组arr，长度为N，如果某个数出现次数大于N/2，称该数为水王数，如果arr中有水王数，打印这个数；如果没有水王数，打印没有水王数
要求时间复杂度O(N)，额外空间复杂度O(1)
扩展1：摩尔投票
扩展2：给定一个正数K，返回所有出现次数>N/K的数

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。
找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
Leetcode题目：https://leetcode.com/problems/minimum-cost-to-merge-stones/



24 大厂高频算法和数据结构面试题24

题目：

给定一个正数数组arr，长度一定大于6（>=7），一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数
分割点的数字直接删除，不属于任何4个部分中的任何一个。返回有没有可能分出的4个部分累加和一样大
如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}。可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！

长度为N的数组arr，一定可以组成N^2个数字对。例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)
也就是任意两个数都可以，而且自己和自己也算数字对。数字对怎么排序？第一维数据从小到大；第一维数据一样的，第二维数组也从小到大
所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)。给定一个数组arr，和整数k，返回第k小的数值对

正常的里程表会依次显示自然数表示里程
吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数
正常：1 2 3 4 5 6 7 8  9 10 11 12 13 14 15
吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 ... 38 39 50 51 52 53 55
给定一个吉祥里程表的数字num(当然这个数字中不含有4)
返回这个数字代表的真实里程

N * M的棋盘（N和M是输入参数），每种颜色的格子数必须相同的，上下左右的格子算相邻，相邻格子染的颜色必须不同，所有格子必须染色，返回至少多少种颜色可以完成任务

给定两个字符串str1和str2，在str1中寻找一个最短子串，能包含str2的所有字符，字符顺序无所谓，str1的这个最短子串也可以包含多余的字符，返回这个最短包含子串

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）
Leetcode题目：https://leetcode.com/problems/remove-duplicate-letters/



25 大厂高频算法和数据结构面试题25

题目：

An IP address is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a decimal number and the dot character '.' splits the groups.
For example, the binary number 00001111 10001000 11111111 01101011 (spaces added for clarity) formatted as an IP address would be "15.136.255.107".
A CIDR block is a format used to denote a specific set of IP addresses. It is a string consisting of a base IP address, followed by a slash, followed by a prefix length k.
The addresses it covers are all the IPs whose first k bits are the same as the base IP address.
For example, "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP address whose binary representation matches
01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in the set covered by the CIDR block.
You are given a start IP address ip and the number of IP addresses we need to cover n. 
Your goal is to use as few CIDR blocks as possible to cover all the IP addresses in the inclusive range [ip, ip + n - 1] exactly
No other IP addresses outside of the range should be covered.
Return the shortest list of CIDR blocks that covers the range of IP addresses. If there are multiple answers, return any of them.
Leetcode题目：https://leetcode.com/problems/ip-to-cidr/

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组
注意：答案中不可以包含重复的三元组
Leetcode题目：https://leetcode.com/problems/3sum/

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
Leetcode题目：https://leetcode.com/problems/max-points-on-a-line/

良好加油站问题最优解
Leetcode题目：https://leetcode.com/problems/gas-station/



26 大厂高频算法和数据结构面试题26

题目：

有三个有序数组，分别在三个数组中挑出3个数，x、y、z。返回 |x-y| + |y-z| + |z-x|最小是多少？
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格
同一个单元格内的字母在一个单词中不允许被重复使用。
Leetcode题目：https://leetcode.com/problems/word-search-ii/

给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。
输入: num = "123", target = 6
输出: ["1+2+3", "1*2*3"] 
示例 2:
输入: num = "232", target = 8
输出: ["2*3+2", "2+3*2"]
示例 3:
输入: num = "105", target = 5
输出: ["1*0+5","10-5"]
示例 4:
输入: num = "00", target = 0
输出: ["0+0", "0-0", "0*0"]
Leetcode题目：https://leetcode.com/problems/expression-add-operators/

按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：
每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList
请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表
每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回
Leetcode题目：https://leetcode.com/problems/word-ladder-ii/



27 大厂高频算法和数据结构面试题27

题目：

每一个项目都有三个数，[a,b,c]表示这个项目a和b乐队参演，花费为c
每一个乐队可能在多个项目里都出现了，但是只能被挑一次
nums是可以挑选的项目数量，所以一定会有nums*2只乐队被挑选出来
返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少？
如果怎么都无法在nums轮请到nums*2只乐队且每只乐队只能被挑一次，返回-1
nums<9，programs长度小于500，每组测试乐队的全部数量一定是nums*2，且标号一定是0 ~ nums*2-1

企鹅厂每年都会发文化衫，文化衫有很多种，厂庆的时候，企鹅们都需要穿文化衫来拍照
一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿一种文化衫
我们将这些回答放在answers数组里，返回鹅厂中企鹅的最少数量
Leetcode题目：https://leetcode.com/problems/rabbits-in-forest/

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标
你可以假设每种输入只会对应一个答案。但是数组中同一个元素在答案里不能重复出现，你可以按任意顺序返回答案
Leetcode题目：https://leetcode.com/problems/two-sum/

给你一个32位的有符号整数x，返回将x中的数字部分反转后的结果，如果反转后整数超过 32 位的有符号整数的范围，就返回0
假设环境不允许存储 64 位整数（有符号或无符号）
Leetcode题目：https://leetcode.com/problems/reverse-integer/



28 大厂高频算法和数据结构面试题28

题目：

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为231 − 1。
返回整数作为最终结果。
注意：本题中的空白字符只包括空格字符 ' ' 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
Leetcode题目：https://leetcode.com/problems/string-to-integer-atoi/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字
Leetcode题目：https://leetcode.com/problems/integer-to-roman/

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
Leetcode题目：https://leetcode.com/problems/roman-to-integer/

编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 ""。
Leetcode题目：https://leetcode.com/problems/longest-common-prefix/

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
按键2对应：'a', 'b', 'c'
按键3对应：'d', 'e', 'f'
按键4对应：'g', 'h', 'i'
按键5对应：'j', 'k', 'l'
按键6对应：'m', 'n', 'o'
按键7对应：'p', 'q', 'r', 's'
按键8对应：'t', 'u', 'v'
按键9对应：'w', 'x', 'y', 'z'
示例 1：
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：
输入：digits = ""
输出：[]
示例 3：
输入：digits = "2"
输出：["a","b","c"]
Leetcode题目：https://leetcode.com/problems/letter-combinations-of-a-phone-number/

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
Leetcode题目：https://leetcode.com/problems/remove-nth-node-from-end-of-list/

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
Leetcode题目：https://leetcode.com/problems/valid-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：
输入：n = 1
输出：["()"]
Leetcode题目：https://leetcode.com/problems/generate-parentheses/

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
Leetcode题目：https://leetcode.com/problems/remove-duplicates-from-sorted-array/

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
要求：设计并实现时间复杂度为 O(log n) 的算法
Leetcode题目：https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。
注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
Leetcode题目：https://leetcode.com/problems/valid-sudoku/

编写一个程序，通过填充空格来解决数独问题。
数独的解法需遵循如下规则：
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
数独部分空格内已填入了数字，空白格用 '.' 表示。
Leetcode题目：https://leetcode.com/problems/sudoku-solver/

给定一个正整数 n ，输出的第 n 项。
前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
返回第N项的字符串
Leetcode题目：https://leetcode.com/problems/count-and-say/

给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。
字母异位词指字母相同，但排列不同的字符串。
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
示例 2:
输入: strs = [""]
输出: [[""]]
示例 3:
输入: strs = ["a"]
输出: [["a"]]
Leetcode题目：https://leetcode.com/problems/group-anagrams/



29 大厂高频算法和数据结构面试题29

题目：

整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
Leetcode题目：https://leetcode.com/problems/search-in-rotated-sorted-array/

实现 pow(x, n) ，即计算 x 的 n 次幂函数
Leetcode题目：https://leetcode.com/problems/powx-n/

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]
请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间
Leetcode题目：https://leetcode.com/problems/merge-intervals/

一个机器人位于一个 m x n 网格的左上角
机器人每次只能向下或者向右移动一步
机器人试图达到网格的右下角
问总共有多少条不同的路径？
Leetcode题目：https://leetcode.com/problems/unique-paths/

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加1
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字
你可以假设除了整数 0 之外，这个整数不会以零开头
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：
输入：digits = [9,9,9]
输出：[1,0,0,0]
解释：输入数组表示数字 1000。
示例 3：
输入：digits = [0]
输出：[1]
Leetcode题目：https://leetcode.com/problems/plus-one/

实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4
输出: 2
示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。
Leetcode题目：https://leetcode.com/problems/sqrtx/

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
进阶：
一个直观的解决方案是使用 O(m * n) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？
Leetcode题目：https://leetcode.com/problems/set-matrix-zeroes/



30 大厂高频算法和数据结构面试题30

题目：

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
Leetcode题目 : https://leetcode.com/problems/word-search/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
Leetcode题目 : https://leetcode.com/problems/merge-sorted-array/

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
Leetcode题目 : https://leetcode.com/problems/decode-ways/

一条包含字母 A-Z 的消息通过以下的方式进行了编码：
'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。
给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。
同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）
示例 1 :
输入: "*"
输出: 9
解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
示例 2 :
输入: "1*"
输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
Leetcode题目 : https://leetcode.com/problems/decode-ways-ii/

给定一个二叉树，判断其是否是一个有效的二叉搜索树。
Leetcode题目 : https://leetcode.com/problems/validate-binary-search-tree/

给定一个二叉树，检查它是否是镜像对称的。
Leetcode题目 : https://leetcode.com/problems/symmetric-tree/

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
Leetcode题目 : https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过1的二叉树
Leetcode题目 : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
进阶：
这棵树如果是普通二叉树，该怎么做。
你只能使用常量级额外空间。
Leetcode题目 : https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
Leetcode题目 : https://leetcode.com/problems/pascals-triangle/

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
你可以优化你的算法到 O(1) 空间复杂度吗？
Leetcode题目 : https://leetcode.com/problems/pascals-triangle-ii/

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和。
进阶：
如果返回最大路径和上的所有节点，该怎么做？
Leetcode题目 : https://leetcode.com/problems/binary-tree-maximum-path-sum/



31 大厂高频算法和数据结构面试题31

题目：

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
示例 2:
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
Leetcode题目 : https://leetcode.com/problems/valid-palindrome/

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord
序列中最后一个单词是 endWord
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
Leetcode题目 : https://leetcode.com/problems/word-ladder/

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
Leetcode题目 : https://leetcode.com/problems/surrounded-regions/

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
Leetcode题目 : https://leetcode.com/problems/word-break/
Lintcode题目 : https://www.lintcode.com/problem/107/

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
示例 1：
输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：
输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
示例 3：
输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]
Leetcode题目 : https://leetcode.com/problems/word-break-ii/

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表头节点。
进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
Leetcode题目 : https://leetcode.com/problems/sort-list/

根据 逆波兰表示法，求表达式的值。
有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
示例 1：
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
Leetcode题目 : https://leetcode.com/problems/evaluate-reverse-polish-notation/



32 大厂高频算法和数据结构面试题32

题目：

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
Leetcode题目 : https://leetcode.com/problems/maximum-product-subarray/

给定一个有序无重复的数组nums， 和两个整数lower和upper， 返回[lower,upper]上所有缺失的数字段
示例1:
nums = [0,1,3,50,75], lower = 0, upper = 99
输出:["2","4->49","51->74","76->99"]
示例2:
nums = [], lower = 1, upper = 1
输出: ["1"]
示例3:
nums = [], lower = -3, upper = -1
输出： ["-3->-1"]
示例4:
nums = [-1], lower = -1, upper = -1
输出: []
示例5: 
nums = [-1], lower = -2, upper = -1
输出: ["-2"]
Leetcode题目 : https://leetcode.com/problems/missing-ranges/

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1：
输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：
输入：numerator = 2, denominator = 1
输出："2"
示例 3：
输入：numerator = 2, denominator = 3
输出："0.(6)"
示例 4：
输入：numerator = 4, denominator = 333
输出："0.(012)"
示例 5：
输入：numerator = 1, denominator = 5
输出："0.2"
Leetcode题目 : https://leetcode.com/problems/fraction-to-recurring-decimal/

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。
例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
示例 1:
输入: columnTitle = "A"
输出: 1
示例 2:
输入: columnTitle = "AB"
输出: 28
示例 3:
输入: columnTitle = "ZY"
输出: 701
示例 4:
输入: columnTitle = "FXSHRXW"
输出: 2147483647
Leetcode题目 : https://leetcode.com/problems/excel-sheet-column-number/

给定一个整数 n，返回 n! 结果尾数中零的数量。
示例 1:
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
Leetcode题目 : https://leetcode.com/problems/factorial-trailing-zeroes/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
Leetcode题目 : https://leetcode.com/problems/rotate-array/

颠倒给定的 32 位无符号整数的二进制位。
进阶:
如果多次调用这个函数，你将如何优化你的算法？
示例 1：
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
Leetcode题目 : https://leetcode.com/problems/reverse-bits/

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
提示：
输入必须是长度为 32 的 二进制串 。
进阶：
如果多次调用这个函数，你将如何优化你的算法？
Leetcode题目 : https://leetcode.com/problems/number-of-1-bits/

编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
示例 2：
输入：n = 2
输出：false
提示：
1 <= n <= 2^31 - 1
Leetcode题目 : https://leetcode.com/problems/happy-number

统计所有小于非负整数 n 的质数的数量。
示例 1：
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：
输入：n = 0
输出：0
示例 3：
输入：n = 1
输出：0
提示：
0 <= n <= 5 * 10^6
Leetcode题目 : https://leetcode.com/problems/count-primes/

拼多多笔试题 : 给定一个数组arr，arr[i] = j，表示第i号试题的难度为j。给定一个非负数M
想出一张卷子，对于任何相邻的两道题目，前一题的难度不能超过后一题的难度+M
返回所有可能的卷子种数



33 大厂高频算法和数据结构面试题33

题目：

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
Leetcode题目 : https://leetcode.com/problems/course-schedule/

现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
Leetcode题目 : https://leetcode.com/problems/course-schedule-ii/

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：
输入：nums = [0]
输出：0
Leetcode题目 : https://leetcode.com/problems/house-robber-ii/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
Leetcode题目 : https://leetcode.com/problems/delete-node-in-a-linked-list/

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4]
输出: [24,12,8,6]
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
Leetcode题目 : https://leetcode.com/problems/product-of-array-except-self/

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true
示例 2:
输入: s = "rat", t = "car"
输出: false
Leetcode题目 : https://leetcode.com/problems/valid-anagram/

给定一个二维数组，实现二维数组的迭代器，包含hasNext()和next()两个迭代器常见方法。
Leetcode题目 : https://leetcode.com/problems/flatten-2d-vector/

出版社印发了一个名单，名单上的每一行都是一个字符串，字符串都是小写字母，但是字符串出现的先后顺序和日常的字典序不一样
现在怀疑出版社内部对于字符有自己的字典序规则，请根据字符串之间出现的顺序，返回可能存在的、出版社内部的字符顺序
如果从名单来看不存在这样的字符顺序，返回空字符串
Leetcode题目 : https://leetcode.com/problems/alien-dictionary/

给定一个数n，所有人的编号从0到n-1
给定一个函数 boolean know(int i, int j)，该函数表示i这个人认不认识j这个人，认识关系是单向的
有了这个函数，你可以检查认识这件事情。
规定何为明星？1）所有人都认识这个人。2）这个人不认识自己之外的所有人。那么这个人就是明星
利用know函数，找到明星，返回明星的编号，如果没有明星返回-1。
Leetcode题目 : https://leetcode.com/problems/find-the-celebrity/

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
Leetcode题目 : https://leetcode.com/problems/perfect-squares/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
Leetcode题目 : https://leetcode.com/problems/move-zeroes/



34 大厂高频算法和数据结构面试题34

题目：

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。
你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。
Leetcode题目 : https://leetcode.com/problems/find-the-duplicate-number/

生命游戏，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。
每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。
Leetcode题目 : https://leetcode.com/problems/game-of-life/

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
Leetcode题目 : https://leetcode.com/problems/find-median-from-data-stream/

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
示例：
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
Leetcode题目 : https://leetcode.com/problems/count-of-smaller-numbers-after-self/

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
示例 1：
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
示例 2：
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
进阶：你能用 O(n) 时间复杂度和原地 O(1) 额外空间来实现吗？
Leetcode题目 : https://leetcode.com/problems/wiggle-sort-ii/

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
Leetcode题目 : https://leetcode.com/problems/power-of-three/

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1:
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:
应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
Leetcode题目 : https://leetcode.com/problems/odd-even-linked-list/

给定一个字符串str，和一个正数k，返回字符种类不超过k种的最长子串长度。
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/

给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；
该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
示例 1：
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
示例 2：
输入：nestedList = [1,[4,[6]]]
输出：[1,4,6]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
Leetcode题目 : https://leetcode.com/problems/flatten-nested-list-iterator/

tic-tac-toe游戏，不知道的同学可以自行搜索。请实现以下类TicTacToe。
构造方法：TicTacToe(int n) : TicTacToe游戏的类，n表示目前在n*n的棋盘上玩游戏。
内部方法：int move(int i, int j, int p) : p只可能是1和2，表示玩家1还是玩家2。当前玩家在i行j列上走了一步。返回值只可能是0、1、2，0表示没有玩家赢；1表示玩家1赢了；2表示玩家2赢了。
Leetcode题目 : https://leetcode.com/problems/design-tic-tac-toe/

设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。
remove(val)：元素 val 存在时，从集合中移除该项。
getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。
Leetcode题目 : https://leetcode.com/problems/insert-delete-getrandom-o1/

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
Leetcode题目 : https://leetcode.com/problems/shuffle-an-array/



35 大厂高频算法和数据结构面试题35

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:
输入: nums = [1], k = 1
输出: [1]
提示：
1 <= nums.length <= 10^5
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。
Leetcode题目 : https://leetcode.com/problems/top-k-frequent-elements/

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
示例 1：
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
提示：
1 <= s.length <= 10^4
s 仅由小写英文字母组成
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/

写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。
示例：
n = 15,
返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
Leetcode题目 : https://leetcode.com/problems/fizz-buzz/

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
例如:
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出:
2
解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
Leetcode题目 : https://leetcode.com/problems/4sum-ii/

给定一个未排序的整数数组，找到最长递增子序列的个数。
示例 1:
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
Leetcode题目 : https://leetcode.com/problems/number-of-longest-increasing-subsequence/

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
Leetcode题目 : https://leetcode.com/problems/longest-univalue-path/

来自真实笔试
给定一个长度len，表示一共有几位
所有字符都是小写(a~z)，可以生成长度为1，长度为2，
长度为3...长度为len的所有字符串
如果把所有字符串根据字典序排序，每个字符串都有所在的位置。
给定一个字符串str，给定len，请返回str是总序列中的第几个
比如len = 4，字典序的前几个字符串为:
a aa aaa aaaa aaab ... aaaz ... azzz b ba baa baaa ... bzzz c ...
a是这个序列中的第1个，bzzz是这个序列中的第36558个

来自小红书
[0,4,7] ： 0表示这里石头没有颜色，如果变红代价是4，如果变蓝代价是7
[1,X,X] ： 1表示这里石头已经是红，而且不能改颜色，所以后两个数X无意义
[2,X,X] ： 2表示这里石头已经是蓝，而且不能改颜色，所以后两个数X无意义
颜色只可能是0、1、2，代价一定>=0
给你一批这样的小数组，要求最后必须所有石头都有颜色，且红色和蓝色一样多，返回最小代价
如果怎么都无法做到所有石头都有颜色、且红色和蓝色一样多，返回-1

来自小红书
一场电影开始和结束时间可以用一个小数组来表示["07:30","12:00"]
已知有2000场电影开始和结束都在同一天，这一天从00:00开始到23:59结束
一定要选3场完全不冲突的电影来观看，返回最大的观影时间
如果无法选出3场完全不冲突的电影来观看，返回-1

来自网易
map[i][j] == 0，代表(i,j)是海洋，渡过的话代价是2
map[i][j] == 1，代表(i,j)是陆地，渡过的话代价是1
map[i][j] == 2，代表(i,j)是障碍，无法渡过
每一步上、下、左、右都能走，返回从左上角走到右下角最小代价是多少，如果无法到达返回-1

来自网易
给定一个正数数组arr，表示每个小朋友的得分
任何两个相邻的小朋友，如果得分一样，怎么分糖果无所谓，但如果得分不一样，分数大的一定要比分数少的多拿一些糖果
假设所有的小朋友坐成一个环形，返回在不破坏上一条规则的情况下，需要的最少糖果数



36 大厂高频算法和数据结构面试题36

来自网易
规定：L[1]对应a，L[2]对应b，L[3]对应c，...，L[25]对应y
S1 = a
S(i) = S(i-1) + L[i] + reverse(invert(S(i-1)));
解释invert操作：
S1 = a
S2 = aby
假设invert(S(2)) = 甲乙丙
a + 甲 = 26, 那么 甲 = 26 - 1 = 25 -> y
b + 乙 = 26, 那么 乙 = 26 - 2 = 24 -> x
y + 丙 = 26, 那么 丙 = 26 - 25 = 1 -> a
如上就是每一位的计算方式，所以invert(S2) = yxa
所以S3 = S2 + L[3] + reverse(invert(S2)) = aby + c + axy = abycaxy
invert(abycaxy) = yxawyba, 再reverse = abywaxy
所以S4 = abycaxy + d + abywaxy = abycaxydabywaxy
直到S25结束
给定两个参数n和k，返回Sn的第k位是什么字符，n从1开始，k从1开始
比如n=4，k=2，表示S4的第2个字符是什么，返回b字符
 
来自京东
把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分
比如 : 01010101
01 01 01 01 这是一种切法，0和1比例为 1 : 1
0101 0101 也是一种切法，0和1比例为 1 : 1
两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4
比如 : 00001111
只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1
给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans
其中ans[i] = str[0...i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少
输入: str = "010100001"
输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
 
来自美团
给定两个字符串s1和s2
返回在s1中有多少个子串等于s2
 
来自美团
() 分值为2
(()) 分值为3
((())) 分值为4
也就是说，每包裹一层，分数就是里面的分值+1
()() 分值为2 * 2
(())() 分值为3 * 2
也就是说，每连接一段，分数就是各部分相乘，以下是一个结合起来的例子
(()())()(()) -> (2 * 2 + 1) * 2 * 3 -> 30
给定一个括号字符串str，已知str一定是正确的括号结合，不会有违规嵌套
返回分数
 
来自美团
给定一个数组arr，长度为N，做出一个结构，可以高效的做如下的查询
1) int querySum(L,R) : 查询arr[L...R]上的累加和
2) int queryAim(L,R) : 查询arr[L...R]上的目标值，目标值定义如下：
       假设arr[L...R]上的值为[a,b,c,d]，a+b+c+d = s
       目标值为 : (s-a)^2 + (s-b)^2 + (s-c)^2 + (s-d)^2
3) int queryMax(L,R) : 查询arr[L...R]上的最大值
要求：
1) 初始化该结构的时间复杂度不能超过O(N*logN)
2) 三个查询的时间复杂度不能超过O(logN)
3) 查询时，认为arr的下标从1开始，比如 : 
   arr = [ 1, 1, 2, 3 ];
   querySum(1, 3) -> 4
   queryAim(2, 4) -> 50
   queryMax(1, 4) -> 3

来自美团
有一棵树，给定头节点h，和结构数组m，下标0弃而不用
比如h = 1, m = [ [] , [2,3], [4], [5,6], [], [], []]
表示1的孩子是2、3; 2的孩子是4; 3的孩子是5、6; 4、5和6是叶节点，都不再有孩子
每一个节点都有颜色，记录在c数组里，比如c[i] = 4, 表示节点i的颜色为4
一开始只有叶节点是有权值的，记录在w数组里，
比如，如果一开始就有w[i] = 3, 表示节点i是叶节点、且权值是3
现在规定非叶节点i的权值计算方式：
根据i的所有直接孩子来计算，假设i的所有直接孩子，颜色只有a,b,k
w[i] = Max {
             (颜色为a的所有孩子个数 + 颜色为a的孩子权值之和), 
             (颜色为b的所有孩子个数 + 颜色为b的孩子权值之和),
             (颜色为k的所有孩子个数 + 颜色k的孩子权值之和)
           }
请计算所有孩子的权值并返回
 
来自腾讯
给定一个单链表的头节点head，每个节点都有value(>0)，给定一个正数m
value%m的值一样的节点算一类
请把所有的类根据单链表的方式重新连接好，返回每一类的头节点
 
来自腾讯
给定一个数组arr，当拿走某个数a的时候，其他所有的数都+a
请返回最终所有数都拿走的最大分数
比如: [2,3,1]
当拿走3时，获得3分，数组变成[5,4]
当拿走5时，获得5分，数组变成[9]
当拿走9时，获得9分，数组变成[]
这是最大的拿取方式，返回总分17
 
来自腾讯
给定一个正数数组arr，代表每个人的体重。给定一个正数limit代表船的载重，所有船都是同样的载重量
每个人的体重都一定不大于船的载重
要求：
1, 可以1个人单独一搜船
2, 一艘船如果坐2人，两个人的体重相加需要是偶数，且总体重不能超过船的载重
3, 一艘船最多坐2人
返回如果想所有人同时坐船，船的最小数量
 
来自腾讯
给定一个字符串str，和一个正数k
返回长度为k的所有子序列中，字典序最大的子序列
 
来自哈喽单车(Leetcode原题)
Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。
一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。
如果石子堆里没有石子了，则无法操作的玩家输掉游戏。
给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。
leetcode原题 : https://leetcode.com/problems/stone-game-iv/

来自三七互娱(Leetcode原题)
给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
Leetcode原题 : https://leetcode.com/problems/bus-routes/



37 大厂高频算法和数据结构面试题37

给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
Leetcode题目 : https://leetcode.com/problems/flatten-binary-tree-to-linked-list/

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
Leetcode题目 : https://leetcode.com/problems/maximal-square/

翻转一棵二叉树
任何节点的左右两个孩子交换
Leetcode题目 : https://leetcode.com/problems/invert-binary-tree/

给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
Leetcode题目 : https://leetcode.com/problems/decode-string/

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
Leetcode题目 : https://leetcode.com/problems/queue-reconstruction-by-height/

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
Leetcode题目 : https://leetcode.com/problems/path-sum-iii/

来自网易
刚入职网易互娱，新人mini项目便如火如荼的开展起来。为了更好的项目协作与管理，
小易决定将学到的甘特图知识用于mini项目时间预估。小易先把项目中每一项工作以任务的形式列举出来，
每项任务有一个预计花费时间与前置任务表，必须完成了该任务的前置任务才能着手去做该任务。
作为经验PM，小易把任务划分得井井有条，保证没有前置任务或者前置任务全数完成的任务，都可以同时进行。
小易给出了这样一个任务表，请作为程序的你计算需要至少多长时间才能完成所有任务。
输入第一行为一个正整数T，表示数据组数。
对于接下来每组数据，第一行为一个正整数N，表示一共有N项任务。
接下来N行，每行先有两个整数Di和Ki，表示完成第i个任务的预计花费时间为Di天，该任务有Ki个前置任务。
之后为Ki个整数Mj，表示第Mj个任务是第i个任务的前置任务。
数据范围：对于所有数据，满足1<=T<=3, 1<=N, Mj<=100000, 0<=Di<=1000, 0<=sum(Ki)<=N*2。

来自字节
扑克牌中的红桃J和梅花Q找不到了，为了利用剩下的牌做游戏，小明设计了新的游戏规则
1) A,2,3,4....10,J,Q,K分别对应1到13这些数字，大小王对应0
2) 游戏人数为2人，轮流从牌堆里摸牌，每次摸到的牌只有“保留”和“使用”两个选项，且当前轮必须做出选择
3) 如果选择“保留”当前牌，那么当前牌的分数加到总分里，并且可以一直持续到游戏结束
4) 如果选择“使用”当前牌，那么当前牌的分数*3，加到总分上去，但是只有当前轮，下一轮，下下轮生效，之后轮效果消失。
5) 每一轮总分大的人获胜
假设小明知道每一轮对手做出选择之后的总分，返回小明在每一轮都赢的情况下，最终的最大分是多少
如果小明怎么都无法保证每一轮都赢，返回-1



38 大厂高频算法和数据结构面试题38

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
异位词 指字母相同，但排列不同的字符串。
示例 1:
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
示例 2:
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
提示:
1 <= s.length, p.length <= 3 * 10^4
s 和 p 仅包含小写字母
Leetcode题目 : https://leetcode.com/problems/find-all-anagrams-in-a-string/

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。
示例 1：
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：
输入：nums = [1,1]
输出：[2]
提示：
n == nums.length
1 <= n <= 10^5
1 <= nums[i] <= n
进阶：你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。
Leetcode题目 : https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
Leetcode题目 : https://leetcode.com/problems/merge-two-binary-trees/

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。
在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。
然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的 最短时间 。
示例 1：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
示例 2：
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类
示例 3：
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
Leetcode题目 : https://leetcode.com/problems/task-scheduler/

给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。
回文字符串 是正着读和倒过来读一样的字符串。
子字符串 是字符串中的由连续字符组成的一个序列。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
示例 1：
输入：s = "abc"
输出：3
解释：三个回文子串: "a", "b", "c"
示例 2：
输入：s = "aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
提示：
1 <= s.length <= 1000
s 由小写英文字母组成
Leetcode题目 : https://leetcode.com/problems/palindromic-substrings/

请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。
示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
示例 2:
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
提示：
1 <= temperatures.length <= 10^5
30 <= temperatures[i] <= 100
Leetcode题目 : https://leetcode.com/problems/daily-temperatures/

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。
示例：
输入：S = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
提示：
S的长度在[1, 500]之间。
S只包含小写字母 'a' 到 'z' 。
Leetcode题目 : https://leetcode.com/problems/partition-labels/

来自字节
给定两个数a和b
第1轮，把1选择给a或者b
第2轮，把2选择给a或者b
...
第i轮，把i选择给a或者b
想让a和b的值一样大，请问至少需要多少轮？

360笔试题
长城守卫军
题目描述：
长城上有连成一排的n个烽火台，每个烽火台都有士兵驻守。
第i个烽火台驻守着ai个士兵，相邻峰火台的距离为1。另外，有m位将军，
每位将军可以驻守一个峰火台，每个烽火台可以有多个将军驻守，
将军可以影响所有距离他驻守的峰火台小于等于x的烽火台。
每个烽火台的基础战斗力为士兵数，另外，每个能影响此烽火台的将军都能使这个烽火台的战斗力提升k。
长城的战斗力为所有烽火台的战斗力的最小值。
请问长城的最大战斗力可以是多少？
输入描述
第一行四个正整数n,m,x,k(1<=x<=n<=10^5,0<=m<=10^5,1<=k<=10^5)
第二行n个整数ai(0<=ai<=10^5)
输出描述 仅一行，一个整数，表示长城的最大战斗力
样例输入
5 2 1 2
4 4 2 4 4
样例输出
6



39 大厂高频算法和数据结构面试题39

来自腾讯
给定一个只由0和1组成的字符串S，假设下标从1开始，规定i位置的字符价值V[i]计算方式如下:
1) i == 1时，V[i] = 1
2) i > 1时，如果S[i] != S[i-1]，V[i] = 1
3) i > 1时，如果S[i] == S[i-1]，V[i] = V[i-1] + 1
你可以随意删除S中的字符，返回整个S的最大价值
字符串长度<=5000

来自腾讯
给定一个长度为n的数组arr，求有多少个子数组满足:
子数组两端的值，是这个子数组的最小值和次小值，最小值和次小值谁在最左和最右无所谓
n<=100000

来自百度
给定一个字符串str，和一个正数k
str子序列的字符种数必须是k种，返回有多少子序列满足这个条件
已知str中都是小写字母

来自京东
给定一个二维数组matrix，matrix[i][j] = k代表:
从(i,j)位置可以随意往右跳<=k步，或者从(i,j)位置可以随意往下跳<=k步
如果matrix[i][j] = 0，代表来到(i,j)位置必须停止
返回从matrix左上角到右下角，至少要跳几次
已知matrix中行数n <= 5000, 列数m <= 5000
matrix中的值 <= 1000

真实笔试，忘了哪个公司，但是绝对大厂
一个子序列的消除规则如下:
1) 在某一个子序列中，如果'1'的左边有'0'，那么这两个字符->"01"可以消除
2) 在某一个子序列中，如果'3'的左边有'2'，那么这两个字符->"23"可以消除
3) 当这个子序列的某个部分消除之后，认为其他字符会自动贴在一起，可以继续寻找消除的机会
比如，某个子序列"0231"，先消除掉"23"，那么剩下的字符贴在一起变成"01"，继续消除就没有字符了
如果某个子序列通过最优良的方式，可以都消掉，那么这样的子序列叫做“全消子序列”
一个只由'0'、'1'、'2'、'3'四种字符组成的字符串str，可以生成很多子序列，返回“全消子序列”的最大长度
字符串str长度 <= 200



40 大厂高频算法和数据结构面试题40

腾讯
分裂问题
一个数n，可以分裂成一个数组[n/2, n%2, n/2]
这个数组中哪个数不是1或者0，就继续分裂下去
比如 n = 5，一开始分裂成[2, 1, 2]
[2, 1, 2]这个数组中不是1或者0的数，会继续分裂下去，比如两个2就继续分裂
[2, 1, 2] -> [1, 0, 1, 1, 1, 0, 1]
那么我们说，5最后分裂成[1, 0, 1, 1, 1, 0, 1]
每一个数都可以这么分裂，在最终分裂的数组中，假设下标从1开始
给定三个数n、l、r，返回n的最终分裂数组里[l,r]范围上有几个1
n <= 2 ^ 50，n是long类型
r - l <= 50000，l和r是int类型
我们的课加个码:
n是long类型随意多大都行
l和r也是long类型随意多大都行，但要保证l<=r

来自去哪儿网
给定一个arr，里面的数字都是0~9
你可以随意使用arr中的数字，哪怕打乱顺序也行
请拼出一个能被3整除的，最大的数字，用str形式返回

给定int[][] meetings，比如
{
   {66, 70}   0号会议截止时间66，获得收益70
   {25, 90}   1号会议截止时间25，获得收益90
   {50, 30}   2号会议截止时间50，获得收益30
 }
一开始的时间是0，任何会议都持续10的时间，但是一个会议一定要在该会议截止时间之前开始
只有一个会议室，任何会议不能共用会议室，一旦一个会议被正确安排，将获得这个会议的收益
请返回最大的收益

给定两个数组A和B，长度都是N
A[i]不可以在A中和其他数交换，只可以选择和B[i]交换(0<=i<n)
你的目的是让A有序，返回你能不能做到

来自腾讯
比如arr = {3,1,2,4}
下标对应是：0 1 2 3
你最开始选择一个下标进行操作，一旦最开始确定了是哪个下标，以后都只能在这个下标上进行操作
比如你选定1下标，1下标上面的数字是1，你可以选择变化这个数字，比如你让这个数字变成2
那么arr = {3,2,2,4}
下标对应是：0 1 2 3
因为你最开始确定了1这个下标，所以你以后都只能对这个下标进行操作，
但是，和你此时下标上的数字一样的、且位置连成一片的数字，会跟着一起变
比如你选择让此时下标1的数字2变成3，
那么arr = {3,3,3,4} 可以看到下标1和下标2的数字一起变成3，这是规则！一定会一起变
下标对应是：0 1 2 3
接下来，你还是只能对1下标进行操作，那么数字一样的、且位置连成一片的数字(arr[0~2]这个范围)都会一起变
决定变成4
那么arr = {4,4,4,4}
下标对应是：0 1 2 3
至此，所有数都成一样的了，你在下标1上做了3个决定(第一次变成2，第二次变成3，第三次变成4)，
因为联动规则，arr全刷成一种数字了
给定一个数组arr，最开始选择哪个下标，你随意
你的目的是一定要让arr都成为一种数字，注意联动效果会一直生效
返回最小的变化数
arr长度 <= 200, arr中的值 <= 10^6



41 大厂高频算法和数据结构面试题41

来自小红书
一个无序数组长度为n，所有数字都不一样，并且值都在[0...n-1]范围上
返回让这个无序数组变成有序数组的最小交换次数

来自小红书
有四种诗的韵律分别为: AABB、ABAB、ABBA、AAAA
比如 : 1 1 3 3就属于AABB型的韵律、6 6 6 6就属于AAAA型的韵律等等
一个数组arr，当然可以生成很多的子序列，如果某个子序列一直以韵律的方式连接起来，我们称这样的子序列是有效的
比如, arr = { 1, 1, 15, 1, 34, 1, 2, 67, 3, 3, 2, 4, 15, 3, 17, 4, 3, 7, 52, 7, 81, 9, 9 }
arr的一个子序列为{1, 1, 1, 1, 2, 3, 3, 2, 4, 3, 4, 3, 7, 7, 9, 9}
其中1, 1, 1, 1是AAAA、2, 3, 3, 2是ABBA、4, 3, 4, 3是ABAB、7, 7, 9, 9是AABB
可以看到，整个子序列一直以韵律的方式连接起来，所以这个子序列是有效的
 给定一个数组arr, 返回最长的有效子序列长度
题目限制 : arr长度 <= 4000, arr中的值<= 10^9

来自网易互娱
N个结点之间，表世界存在双向通行的道路，里世界存在双向通行的传送门.
若走表世界的道路，花费一分钟.
若走里世界的传送门，不花费时间，但是接下来一分钟不能走传送门.
输入： T为测试用例的组数，对于每组数据:
第一行：N M1 M2 N代表结点的个数1到N
接下来M1行 每行两个数，u和v，表示表世界u和v之间存在道路
接下来M2行 每行两个数，u和v，表示里世界u和v之间存在传送门
现在处于1号结点，最终要到达N号结点，求最小的到达时间 保证所有输入均有效，不存在环等情况

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
必须 原地 修改，只允许使用额外常数空间。
示例 1：
输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：
输入：nums = [3,2,1]
输出：[1,2,3]
示例 3：
输入：nums = [1,1,5]
输出：[1,5,1]
示例 4：
输入：nums = [1]
输出：[1]
leetcode题目 : https://leetcode.com/problems/next-permutation/



42 大厂高频算法和数据结构面试题42

给定一个二维数组cost[N][K], 
N表示有0...N-1这么多房子，所有房子排成一条直线，i号房子和i-1号房子相邻、也和i+1号房子相邻
K表示有0...K-1这么多颜色，每个房子都必须选择一种颜色
cost[i][j]表示i号房子涂上j颜色的花费，并且要求相邻的房子不能是一种颜色
返回所有房子都涂上颜色，最小的总花费
leetcode题目 : https://leetcode.com/problems/paint-house-ii/

给定一棵搜索二叉树的头节点root，搜索二叉树默认是没有重复值的，给定一个double类型的数target，给定一个正数k
请返回在这棵二叉树里最接近target的k个值，作为链表返回
要求：如果二叉树的节点个数为n，而k相比于n较小的话，实现时间复杂度低于O(n)的方法
leetcode题目 : https://leetcode.com/problems/closest-binary-search-tree-value-ii/

给定一个整数num，返回一个字符串str，是num的英文表达
leetcode题目 : https://leetcode.com/problems/integer-to-english-words/

二维矩阵中只有0和1，每个1可以上、下、左、右的移动
想让所有的1汇聚在一个点上开会，请返回所有1移动的最小距离和
leetcode题目 : https://leetcode.com/problems/best-meeting-point/

给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动
也就是说，每次移动后你的方位会发生逆时针变化
编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。
leetcode题目 : https://leetcode.com/problems/self-crossing/



43 大厂高频算法和数据结构面试题43

来自微软面试
给定一个正数数组arr长度为n、正数x、正数y
你的目标是让arr整体的累加和<=0
你可以对数组中的数num执行以下三种操作中的一种，且每个数最多能执行一次操作 : 
1）不变
2）可以选择让num变成0，承担x的代价
3）可以选择让num变成-num，承担y的代价
返回你达到目标的最小代价
数据规模 : 面试时面试官没有说数据规模

来自360笔试
给定一个正数数组arr，长度为n，下标0~n-1
arr中的0、n-1位置不需要达标，它们分别是最左、最右的位置
中间位置i需要达标，达标的条件是 : arr[i-1] > arr[i] 或者 arr[i+1] > arr[i]哪个都可以
你每一步可以进行如下操作：对任何位置的数让其-1
你的目的是让arr[1~n-2]都达标，这时arr称之为yeah！数组
返回至少要多少步可以让arr变成yeah！数组
数据规模 : 数组长度 <= 10000，数组中的值<=500



44 大厂高频算法和数据结构面试题44

给定两个字符串low和high，它们只由数字字符组成，代表两个数字并且low<=high，返回在[low, high]范围上旋转有效串的数量
旋转有效串：一个字符串以中心点为支点，旋转180度之后依然是原来字符串，叫做旋转有效串，比如：
181旋转之后还是181，是旋转有效串
8008旋转之后还是8008，是旋转有效串
689旋转之后还是689，是旋转有效串
而6816就不是旋转有效串，因为旋转之后是9189
leetcode题目 : https://leetcode.com/problems/strobogrammatic-number-iii/

给定一个二维矩阵，其中的值0代表路，1代表人，2代表障碍
每个人都可以上下左右移动，但是只能走值为0的格子
想把所有的人聚集在某个值为0的地方开会，希望所有人到会议点的总距离最短
返回最短的开会总距离
如果无论如何都无法让所有的人聚集到一起，返回-1
leetcode题目 : https://leetcode.com/problems/shortest-distance-from-all-buildings/

给定一个正整数数组arr，和正数k
如果arr的某个子数组中含有k种不同的数，称这个子数组为有效子数组
返回arr中有效子数组的数量
leetcode题目 : https://leetcode.com/problems/subarrays-with-k-different-integers/



45 大厂高频算法和数据结构面试题45

来自京东笔试
小明手中有n块积木，并且小明知道每块积木的重量。现在小明希望将这些积木堆起来
要求是任意一块积木如果想堆在另一块积木上面，那么要求：
1) 上面的积木重量不能小于下面的积木重量
2) 上面积木的重量减去下面积木的重量不能超过x
3) 每堆中最下面的积木没有重量要求
现在小明有一个机会，除了这n块积木，还可以获得k块任意重量的积木。
小明希望将积木堆在一起，同时希望积木堆的数量越少越好，你能帮他找到最好的方案么？
输入描述:
第一行三个整数n,k,x，1<=n<=200000，0<=x,k<=1000000000
第二行n个整数，表示积木的重量，任意整数范围都在[1,1000000000]
样例输出：
n = 13 k = 1 x = 38
arr : 20 20 80 70 70 70 420 5 1 5 1 60 90
输出：2
解释：
两堆分别是
1 1 5 5 20 20 x 60 70 70 70 80 90
420
其中x是一个任意重量的积木，夹在20和60之间可以让积木继续往上搭

给定两个字符串pattern和s，返回s是否符合pattern的规定
这里的符合是指，pattern里的每个字母和字符串s中子串，存在着单一映射双向连接的对应
例子1：
输入：pattern = "abab", s = "redblueredblue"
输出：true
解释：
映射如下
'a' -> "red"
'b' -> "blue"
例子2
输入：pattern = "aaaa", s = "asdasdasdasd"
输出：true
解释:
映射如下
'a' -> "asd"
例子3
输入: pattern = "abab", s = "asdasdasdasd"
输出: true
解释:
映射如下
'a' -> "a"
'b' -> "sdasd"
例子4
输入：pattern = "aabb", s = "xyzabcxzyabc"
输出：false
Leetcode题目 : https://leetcode.com/problems/word-pattern-ii/

一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）
开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃
示例 1：
输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。
示例 2：
输入：stones = [0,1,2,3,4,8,9,11]
输出：false
解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。
leetcode题目：https://leetcode.com/problems/frog-jump/

给你一个长度为 2 * n 的整数数组。你需要将 nums 分成 两个 长度为 n 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。nums 中每个元素都需要放入两个数组之一。
请你返回 最小 的数组和之差。
数据范围：
1 <= n <= 15
nums.length == 2 * n
-10^7 <= nums[i] <= 10^7
leetcode题目：https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/



46 大厂高频算法和数据结构面试题46

给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
题目数据保证总会存在一个数值和不超过 k 的矩形区域。
leetcode题目：https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/

我们有 N 个与坐标轴对齐的矩形, 其中 N > 0, 判断它们是否能精确地覆盖一个矩形区域。
每个矩形用左下角的点和右上角的点的坐标来表示。例如， 一个单位正方形可以表示为 [1,1,2,2]。 ( 左下角的点的坐标为 (1, 1) 以及右上角的点的坐标为 (2, 2) )。
示例 1:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [3,2,4,4],
  [1,3,2,4],
  [2,3,3,4]
]
返回 true。5个矩形一起可以精确地覆盖一个矩形区域。
示例 2:
rectangles = [
  [1,1,2,3],
  [1,3,2,4],
  [3,1,4,2],
  [3,2,4,4]
]
返回 false。两个矩形之间有间隔，无法覆盖成一个矩形。
示例 3:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [3,2,4,4]
]
返回 false。图形顶端留有间隔，无法覆盖成一个矩形。
示例 4:
rectangles = [
  [1,1,3,3],
  [3,1,4,2],
  [1,3,2,4],
  [2,2,4,4]
]
返回 false。因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。
leetcode题目：https://leetcode.com/problems/perfect-rectangle/

一个字符串可以用缩写的形式来代替，比如单词"substitution"，可以有以下几种缩写：
"s10n" ("s+省略10个字符+n")
"sub4u4" ("sub+省略4个字符+u+省略4个字符")
"12" ("省略12个字符")
等等还有很多
给定一个字符串target、给定一个字符串数组作为字典dictionary，要求把target缩写成长度最短的形式，但是又不会和dictionary中任何单词混淆
返回缩写最短形式的一种结果就可以
例子1：
输入：target = "apple", dictionary = ["blade"]
输出: "a4"
解释：
"apple"最短的缩写是"5"，但是字典中"blade"长度也是5，所以会混淆
"apple"第二短的缩写，有一种是"4e"，但是"4e"也可以是字典中"blade"，所以会混淆
"apple"第二短的缩写，有一种是"a4"，字典中"blade"不以a开头，所以不会混淆
例子2：
输入: target = "apple", dictionary = ["blade","plain","amber"]
输出: "1p3"
leetcode题目：https://leetcode.com/problems/minimum-unique-word-abbreviation/

给定n个字符串，并且每个字符串长度一定是n，请组成单词方阵，比如：
给定4个字符串，长度都是4，["ball","area","lead","lady"]
可以组成如下的方阵：
b a l l
a r e a
l e a d
l a d y
什么叫单词方阵？如上的方阵可以看到，第1行和第1列都是"ball"，第2行和第2列都是"area"，第3行和第3列都是"lead"，第4行和第4列都是"lady"
所以如果有N个单词，单词方阵是指，一个N*N的二维矩阵，并且i行和i列都是某个单词，不要求全部N个单词都在这个方阵里。
请返回所有可能的单词方阵。
示例：
输入: words = ["abat","baba","atan","atal"]
输出: [["baba","abat","baba","atal"],["baba","abat","baba","atan"]]
解释：
可以看到输出里，有两个链表，代表两个单词方阵
第一个如下：
b a b a
a b a t
b a b a
a t a l
这个方阵里没有atan，因为不要求全部单词都在方阵里
第二个如下：
b a b a
a b a t
b a b a
a t a n
这个方阵里没有atal，因为不要求全部单词都在方阵里
leetcode题目：https://leetcode.com/problems/word-squares/



47 大厂高频算法和数据结构面试题47

动态开点线段树详解

给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
leetcode题目：https://leetcode.com/problems/count-of-smaller-numbers-after-self/

给定一个字符串s和一个正数k，重新组织s使得每一种相同的字符距离至少有k，如果无法做到返回空字符串
示例1：
输入：s = "aabbcc", k = 3
输出："abcabc"
示例2：
输入：s = "aaabc", k = 3
输出：""
示例3：
输入：s = "aaadbbcc", k = 2
输出： "abacabcd"
leetcode题目：https://leetcode.com/problems/rearrange-string-k-distance-apart/

设计多叉树的序列化和反序列化方案
序列化：给定一棵多叉树的头节点，把整棵二叉树变成一个字符串返回
反序列化：给定一个字符串，一定是某棵多叉树的序列化结果，生成整棵多叉树并返回头节点
leetcode题目：https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/

一开始所有人手上都是0元钱，[a,b,c]代表，a给b了c元钱。有很多这样的转账记录
那么所有转账完成后，有的人剩余的钱是正数，有的人剩余的钱是负数
现在想重新让所有人的钱都是0元，也就是回到初始状态，请问最少多少笔转账可以做到这一点
例子1：
输入：[[0,1,10],[2,0,5]]
输出：2
解释：0号转给1号10元，2号转给0号5元。上面所有转账完成后：0号-5，1号10，2号-5
所以如果想所有人的钱都是0元，1号需要分别给0号和2号转账5元。所以最少2笔转账。
例子2：
输入：[[0,1,10],[1,0,1],[1,2,5],[2,0,5]]
输出：1
解释：如上的转账完成后，0号-4元，1号4元，2号0元，所以如果想所有人的钱都是0元，1号需要给0号转账4元。所以最少1比交易。
leetcode题目：https://leetcode.com/problems/optimal-account-balancing/

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
在加热器的加热半径范围内的每个房屋都可以获得供暖。
现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
示例 1:
输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
示例 2:
输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。
示例 3：
输入：houses = [1,5], heaters = [2]
输出：3
leetcode题目：https://leetcode.com/problems/heaters/



48 大厂高频算法和数据结构面试题48

来自学员问题
比如{ 5, 3, 1, 4 }
全部数字对是：(5,3)、(5,1)、(5,4)、(3,1)、(3,4)、(1,4)
数字对的差值绝对值： 2、4、1、2、1、3
差值绝对值排序后：1、1、2、2、3、4
给定一个数组arr，和一个正数k
返回arr中所有数字对差值的绝对值，第k小的是多少
arr = { 5, 3, 1, 4 }, k = 4
返回2

给定一个 不含重复 单词的字符串数组 words ，编写一个程序，返回 words 中的所有 连接词 。
连接词 的定义为：一个字符串完全是由至少两个给定数组中的单词组成的。
示例 1：
输入：words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
输出：["catsdogcats","dogcatsdog","ratcatdogcat"]
解释："catsdogcats"由"cats", "dog" 和 "cats"组成; 
     "dogcatsdog"由"dog", "cats"和"dog"组成; 
     "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
示例 2：
输入：words = ["cat","dog","catdog"]
输出：["catdog"]
leetcode题目：https://leetcode.com/problems/concatenated-words/

对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。
示例 1：
输入："13"
输出："3"
解释：13 的 3 进制是 111。
示例 2：
输入："4681"
输出："8"
解释：4681 的 8 进制是 11111。
示例 3：
输入："1000000000000000000"
输出："999999999999999999"
解释：1000000000000000000 的 999999999999999999 进制是 11。
leetcode题目：https://leetcode.com/problems/smallest-good-base/

给定一个二维数组代表迷宫，0代表路，1代表障碍
给定一个球的位置，给定一个洞的位置
你每次可以拨动球往上、下、左、右四个方向中的一个移动，但是球只有撞倒边界或者障碍才会停，只有球停了，你才能再次拨动球。
你的目标是让球进洞，球在移动的过程中只要来到洞的位置，就认为球直接掉进洞里。你需要先保证球进洞的过程中，球移动的距离最短
如果只有一种方案，直接返回这种方案的决定。
如果有多个距离最短的方案，你需要返回其中字典序最小的决定。
比如，假设如下两个方案，球的移动距离都是最小的:
先往左拨动，球撞了墙之后，再往上拨，结果球进洞了，那么决定就是"lu" -> left up
先往上拨动，球撞了墙之后，再往左拨，结果球进洞了，那么决定就是"ul" -> up left
这两个方案如果都是移动距离最小的，那么应该返回lu，因为ul的字典序大
leetcode题目：https://leetcode.com/problems/the-maze-iii/



49 大厂高频算法和数据结构面试题49

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
leetcode题目：https://leetcode.com/problems/combination-sum-iv

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。
注意：1 ≤ k ≤ n ≤ 10^9。
示例 :
输入:
n: 13   k: 2
输出:
10
解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
leetcode题目：https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/

给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。
如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。
例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。
例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。
示例 1：
输入：nums = [2,4,6,8,10]
输出：7
解释：所有的等差子序列为：
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
示例 2：
输入：nums = [7,7,7,7,7]
输出：16
解释：数组中的任意子序列都是等差子序列。
leetcode题目：https://leetcode.com/problems/arithmetic-slices-ii-subsequence/

如下是机器人的类
interface Robot {
  // 如果机器人面朝的方向没有障碍，那么机器人将移动一步，并且返回true
  // 如果机器人面朝的方向有障碍，那么机器人将停在原地，并且返回false
  boolean move();
  //机器人面朝的方向向左转动90度
  void turnLeft();
  //机器人面朝的方向向右转动90度
  void turnRight();
  // 机器人执行原地打扫的动作
  void clean();
}
机器人将空降在房屋的某个地点，这一片局域会有障碍物，房屋的整片区域也一定有边界，边界等同于障碍
房屋的整片区域假设是由1*1的格子拼成的，并且机器人自己占地也是1*1的格子
但是你只能通过机器人的move方法，来让机器人移动并且探知障碍
当然也可以让机器人通过turnLeft或者turnRight方法，来改变面朝的方向
你如何只通过调用上面提到的方法，就控制机器人打扫房间的每个格子
请实现如下的这个方法：
public void cleanRoom(Robot robot) 
leetcode题目：https://leetcode.com/problems/robot-room-cleaner/

规定单词一定要遵循如下的缩写规则：
1）一个单词保留若干长度的前缀，以及保留最后一个字符，中间用数字代表长度的方式来缩写
2）如果缩写后的长度没有原始长度小，则该缩写依然保持原始串的样子
比如:
apple可以缩写成"a3e"，表示保留长度为1的前缀"a"，以及保留最后一个字符"e"，中间用3来代表"ppl"的长度。
apple也可以缩写成"ap2e"，表示保留长度为2的前缀"ap"，以及保留最后一个字符"e"，中间用2来代表"pl"的长度。
apple也可以缩写成"app1e"，但是因为"app1e"没有原始长度小，所以该缩写不能写成"app1e"，应该写成"apple"
也就是说，你可以去选择保留前缀的长度，一旦前缀确定，那么缩写剩下的内容也就都决定了。因为一定要保留最后一个字符，以及中间部分用数字代表长度。
理解了缩写规定之后，请理解对几个字符串都做缩写，但是不能混淆的规定。
比如："abkkf"和"abcde"
"abkkf"缩写为"a3f"，"abcde"缩写为"a3e"，两个字符串的缩写都能变得最短，且不会混淆。因为最后的字符不一样，所以可以区分开
比如："abkkkkc"和"abkskkc"
"abkkkkc"缩写为"a5c"，"abkskkc"缩写为"a5c"，此时发现会混淆，因为缩写之后完全一样
"abkkkkc"缩写为"abkk2c"，"abkskkc"缩写为"abks2c"，这是两个字符串缩写都尽可能短，且不会混淆的缩写。
给你一个字符串数组arr，请完成对每个字符串的缩写，要求任意两个字符串都不会混淆，且每个字符串的缩写都尽可能的短。
例子一
输入：["like","god","internal","me","internet","interval","intension","face","intrusion"]
输出：["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]
例子二
输入: words = ["aa","aaa"]
输出: ["aa","aaa"]
leetcode题目：https://leetcode.com/problems/word-abbreviation/

给定一个数组nums，请将nums切三刀，切出四个部分，被切的数字不算，要求每个部分累加和都一样大，返回能不能做到
比如
输入：nums = [1,2,1,2,1,2,1]
输出：true
解释：
三刀的位置分别为，i = 1, j = 3, k = 5，切完后这三个位置的数不算
所以切出的四个部分为(1) (1) (1) (1)，所以能做到返回true
leetcode题目：https://leetcode.com/problems/split-array-with-equal-sum/

给定一个整数 n ，你需要找到与它最近的回文数（不包括自身）。
“最近的”定义为两个整数差的绝对值最小。
示例 1:
输入: "123"
输出: "121"注意:
n 是由字符串表示的正整数，其长度不超过18。
如果有多个结果，返回最小的那个。
leetcode题目：https://leetcode.com/problems/find-the-closest-palindrome/



50 大厂高频算法和数据结构面试题50

力扣想让一个最优秀的员工在 N 个城市间旅行来收集算法问题。
但只工作不玩耍，聪明的孩子也会变傻，所以您可以在某些特定的城市和星期休假。
您的工作就是安排旅行使得最大化你可以休假的天数，但是您需要遵守一些规则和限制。
规则和限制：
您只能在 N 个城市之间旅行，用 0 到 N-1 的索引表示。一开始，您在索引为0的城市，并且那天是星期一。
这些城市通过航班相连。这些航班用 N*N 矩阵 flights（不一定是对称的）表示，flights[i][j] 代表城市i到城市j的航空状态。如果没有城市i到城市j的航班，
flights[i][j] = 0；否则，flights[i][j] = 1。同时，对于所有的 i，flights[i][i] = 0。
您总共有 K 周（每周7天）的时间旅行。您每天最多只能乘坐一次航班，并且只能在每周的星期一上午乘坐航班。由于飞行时间很短，我们不考虑飞行时间的影响。
对于每个城市，不同的星期您休假天数是不同的，给定一个 N*K 矩阵 days 代表这种限制，days[i][j] 代表您在第j个星期在城市i能休假的最长天数。
给定 flights 矩阵和 days 矩阵，您需要输出 K 周内可以休假的最长天数。
leetcode题目：https://leetcode.com/problems/maximum-vacation-days/

凸包问题经典题
在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。
leetcode题目：https://leetcode.com/problems/erect-the-fence/

设计一个数据结构，和文件系统很像
类中的方法如下：
FileSystem()：初始化这个数据结构
List<String> ls(String path)：如果根据路径path找到的是文件，列出这个文件的名字，如果path找到的是文件夹，列出这个文件夹里的所有文件夹和文件名。（就像ls命令一样）
void mkdir(String path)：根据path路径建出文件夹，如果中间的文件夹缺失，一路都建立出来。
void addContentToFile(String filePath, String content)：根据filePath路径找到文件，如果不存在就新建。然后把内容content加在这个文件的尾部。
String readContentFromFile(String filePath)：根据filePath读出文件内容并返回。
leetcode题目：https://leetcode.com/problems/design-in-memory-file-system/

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。
示例 1:
输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
说明：1 <= n <= 10^9
leetcode题目：https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/



51 大厂高频算法和数据结构面试题51

力扣团队买了一个可编程机器人，机器人初始位置在原点(0, 0)。小伙伴事先给机器人输入一串指令command，机器人就会无限循环这条指令的步骤进行移动。指令有两种：
U: 向y轴正方向移动一格
R: 向x轴正方向移动一格。
不幸的是，在 xy 平面上还有一些障碍物，他们的坐标用obstacles表示。机器人一旦碰到障碍物就会被损毁。
给定终点坐标(x, y)，返回机器人能否完好地到达终点。如果能，返回true；否则返回false。
示例 1：
输入：command = "URR", obstacles = [], x = 3, y = 2
输出：true
解释：U(0, 1) -> R(1, 1) -> R(2, 1) -> U(2, 2) -> R(3, 2)。
示例 2：
输入：command = "URR", obstacles = [[2, 2]], x = 3, y = 2
输出：false
解释：机器人在到达终点前会碰到(2, 2)的障碍物。
示例 3：
输入：command = "URR", obstacles = [[4, 2]], x = 3, y = 2
输出：true
解释：到达终点后，再碰到障碍物也不影响返回结果。
限制：
2 <= command的长度 <= 1000
command由U，R构成，且至少有一个U，至少有一个R
0 <= x <= 1e9, 0 <= y <= 1e9
0 <= obstacles的长度 <= 1000
obstacles[i]不为原点或者终点
链接：https://leetcode-cn.com/problems/programmable-robot/

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。
给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。
示例：
输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。
提示:
整数 1 <= d, t, n <= 10,000 。
你不能同时修两门课程。
leetcode题目：https://leetcode.com/problems/course-schedule-iii/

为搜索引擎设计一个搜索自动完成系统。用户可以输入一个句子(至少一个单词，并以一个特殊的字符'#'结尾)。
对于除'#'之外的每个字符，您需要返回与已输入的句子部分前缀相同的前3个历史热门句子。具体规则如下:
一个句子的热度定义为用户输入完全相同句子的次数。 返回的前3个热门句子应该按照热门程度排序(第一个是最热的)。
如果几个句子的热度相同，则需要使用ascii代码顺序(先显示较小的一个)。 如果少于3个热门句子，那么就尽可能多地返回。 
当输入是一个特殊字符时，它意味着句子结束，在这种情况下，您需要返回一个空列表。 您的工作是实现以下功能:
构造函数:
AutocompleteSystem(String[] sentence, int[] times):这是构造函数。输入是历史数据。
句子是由之前输入的句子组成的字符串数组。Times是输入一个句子的相应次数。您的系统应该记录这些历史数据。
现在，用户想要输入一个新句子。下面的函数将提供用户类型的下一个字符:
List input(char c)：输入c是用户输入的下一个字符。字符只能是小写字母(“a”到“z”)、空格(“”)或特殊字符(“#”)。
另外，前面输入的句子应该记录在系统中。输出将是前3个历史热门句子，它们的前缀与已经输入的句子部分相同。
例子: 
操作:AutocompleteSystem(["i love you"， "island"，"ironman"， "i love leetcode"]， [5,3,2,2]) 系统已经追踪到以下句子及其对应的时间:
"i love you" : 5 times 
"island" : 3 times 
"ironman" : 2 times 
"i love leetcode" : 2 times
现在，用户开始另一个搜索:
操作:输入(“i”) 输出:["i love you"， "island"，"i love leetcode"]
解释: 有四个句子有前缀“i”。其中，《ironman》和《i love leetcode》有着相同的热度。既然“ ” ASCII码为32，“r”ASCII码为114，
那么“i love leetcode”应该在“ironman”前面。此外，我们只需要输出前3个热门句子，所以“ironman”将被忽略。
操作:输入(' ') 输出:[“i love you”，“i love leetcode”] 解释: 只有两个句子有前缀“i”。
操作:输入(' a ') 输出:[] 解释: 没有以“i a”为前缀的句子。
操作:输入(“#”) 输出:[] 解释: 用户完成输入后，在系统中将句子“i a”保存为历史句。下面的输入将被计算为新的搜索。
注意:
输入的句子总是以字母开头，以“#”结尾，两个单词之间只有一个空格。 
要搜索的完整句子不会超过100个。包括历史数据在内的每句话的长度不会超过100句。
设计一个搜索自动补全系统，它需要包含如下两个方法：
构造方法：
AutocompleteSystem(String[] sentences, int[] times): 输入句子sentences，及其出现次数times
输入方法：
List input(char c): 输入字符c可以是26个小写英文字母，也可以是空格，以'#'结尾。返回输入字符前缀对应频率最高的至多3个句子，频率相等时按字典序排列。
leetcode题目：https://leetcode.com/problems/design-search-autocomplete-system/

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。
示例 1：
输入: piles = [3,6,7,11], H = 8
输出: 4
示例 2：
输入: piles = [30,11,23,4,20], H = 5
输出: 30
示例 3：
输入: piles = [30,11,23,4,20], H = 6
输出: 23
leetcode题目：https://leetcode.com/problems/koko-eating-bananas/

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
leetcode题目：https://leetcode.com/problems/uncrossed-lines/



52 大厂高频算法和数据结构面试题52

给定一个数组arr，arr[i] = j，表示来到i位置需要承受j的代价。给定一个正数jump，表示任何位置都可以随意往右跳<=jump步。
要求你从1位置开始，跳到数组最后位置n，在保证最小代价的前提下，返回字典序最小的路径
leetcode题目：https://leetcode.com/problems/coin-path/

给定一个数组bulbs，bulds[i] = j，表示第i天亮起的灯是j。任何一天只会亮一盏灯，如果天数有1~i天，那么灯也一定只有1~i号。
给定一个正数k，如果两盏亮起的灯之间有正好k个不亮的灯，那么说这个是达标情况。
返回最早在哪一天，会出现达标情况，如果不存在达标情况，返回-1
leetcode题目：https://leetcode.com/problems/k-empty-slots/

你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。
给你一个整数数组 rains ，其中：
rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。
请返回一个数组 ans ，满足：
ans.length == rains.length
如果 rains[i] > 0 ，那么ans[i] == -1 。
如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。
如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。
leetcode题目：https://leetcode.com/problems/avoid-flood-in-the-city/


