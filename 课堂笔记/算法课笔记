算法和数据结构新手班

01 位运算、算法是什么、介绍位运算和简单排序

内容：

讲解二进制、位运算

介绍什么是算法

讲解冒泡、选择、插入排序

题目：

实现打印一个整数的二进制

给定一个参数N，返回1!+2!+3!+4!+…+N!的结果

实现冒泡排序

实现选择排序

实现插入排序



02 数据结构的大分类、介绍前缀和与对数器

内容：

什么是数据结构、组成各种数据结构最基本的元件

前缀和数组

随机函数

对数器的使用

题目：

实现前缀和数组

如何用1~5的随机函数加工出1~7的随机函数

如何用a~b的随机函数加工出c~d的随机函数

展示对数器的使用

如何把不等概率随机函数变成等概率随机函数



03 介绍二分法，介绍时间复杂度、动态数组、哈希表和有序表

内容：

二分法

使用二分法解决不同的题目

时间复杂度

动态数组

按值传递、按引用传递

哈希表

有序表

题目：

有序数组中找到num

有序数组中找到>=num最左的位置

有序数组中找到<=num最右的位置

局部最小值问题

哈希表使用的code讲解

有序表使用的code讲解



04 链表相关的简单面试题

内容：

单双链表的定义

栈、队列

双端队列

题目：

反转单链表

反转双链表

用单链表实现队列

用单链表实现栈

用双链表实现双端队列

K个节点的组内逆序调整问题：
给定一个单链表的头节点head，和一个正数k
实现k个节点的小组内部逆序，如果最后一组不够k个就不调整
例子: 
调整前：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8，k = 3
调整后：3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8

两个链表相加问题
给定两个链表的头节点head1和head2，
认为从左到右是某个数字从低位到高位，返回相加之后的链表
例子     4 -> 3 -> 6        2 -> 5 -> 3
返回     6 -> 8 -> 9
解释     634 + 352 = 986

两个有序链表的合并
给定两个有序链表的头节点head1和head2，
返回合并之后的大链表，要求依然有序
例子     1 -> 3 -> 3 -> 5 -> 7   2 -> 2 -> 3 -> 3-> 7
返回     1 -> 2 -> 2 -> 3 -> 3 -> 3 -> 3 -> 5 -> 7



05 位图、位运算实现加减乘除

内容：

位图

位运算使用的进一步学习：实现加减乘除

题目：

现场写位图的code、讲解

位运算的加减乘除



06 比较器、优先级队列、二叉树

内容：

比较器

优先级队列

二叉树的基本遍历

二叉树的递归套路

题目：

补充了一个链表的题目
合并多个有序链表
Leetcode原题，https://leetcode.com/problems/merge-k-sorted-lists

判断两颗树是否结构相同
Leetcode原题，https://leetcode.com/problems/same-tree

判断一棵树是否是镜面树
Leetcode原题，https://leetcode.com/problems/symmetric-tree

返回一棵树的最大深度
Leetcode原题，https://leetcode.com/problems/maximum-depth-of-binary-tree

用先序数组和中序数组重建一棵树
Leetcode原题，https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal

用code展示比较器的使用

二叉树先序、中序、后序遍历的代码实现、介绍递归序



07 继续二叉树的很多题目

内容：

进一步讲解二叉树题目，来熟悉二叉树

题目：

二叉树按层遍历并收集节点
Leetcode原题，https://leetcode.com/problems/binary-tree-level-order-traversal-ii

判断是否是平衡搜索二叉树
Leetcode原题，https://leetcode.com/problems/balanced-binary-tree

在二叉树上能否组成路径和
Leetcode原题，https://leetcode.com/problems/path-sum

在二叉树上收集所有达标的路径和
Leetcode原题，https://leetcode.com/problems/path-sum-ii

判断二叉树是否是搜索二叉树



08 介绍归并排序和快速排序

内容：

讲解一个位运算的题目

归并排序

快速排序

题目：

不要用任何比较判断，返回两个数中较大的数

归并排序的递归实现和非递归实现

快速排序的递归实现和非递归实现



======================================================================================================================================



算法和数据结构体系学习班

00 算法和数据结构学前必看

内容：

算法和数据结构课程体系介绍

算法和数据结构学习路线

算法和数据结构学习方式推荐

算法和数据结构面试软技巧

同学们的各种答疑问题



01 时间复杂度、空间复杂度、对数器和二分法

内容：

评估算法优劣的核心指标

时间复杂度、空间复杂度、估算方式、意义

常数时间的操作

选择排序、冒泡排序、插入排序

最优解

对数器

二分法

题目：

选择排序及其对数器验证

冒泡排序及其对数器验证

插入排序及其对数器验证

有序数组中找到num

有序数组中找到>=num最左的位置

有序数组中找到<=num最右的位置

局部最小值问题
定义何为局部最小值：
arr[0] < arr[1]，0位置是局部最小；
arr[N-1] < arr[N-2]，N-1位置是局部最小；
arr[i-1] > arr[i] < arr[i+1]，i位置是局部最小；
给定一个数组arr，已知任何两个相邻的数都不相等，找到随便一个局部最小位置返回



02 异或运算、进一步认识对数器的重要性

内容：

异或运算的性质

异或运算的题目

题目：

不用额外变量交换两个数的值

不用额外变量交换数组中两个数的值

一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数 

怎么把一个int类型的数，提取出二进制中最右侧的1来

一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数 

一个数组中有一种数出现K次，其他数都出现了M次，
已知M > 1，K < M，找到出现了K次的数
要求额外空间复杂度O(1)，时间复杂度O(N)



03 单双链表、栈和队列、递归和Master公式、哈希表和有序表的使用和性能

内容：

单链表、双链表

栈、队列

递归的物理实质

评估递归复杂度的Master公式

哈希表的使用和性能

有序表的使用和性能

题目：

反转单链表、反转双链表

在链表中删除指定值的所有节点

用双链表实现栈和队列

用环形数组实现栈和队列

实现有getMin功能的栈

两个栈实现队列

两个队列实现栈

用递归行为得到数组中的最大值，并用master公式来估计时间复杂度

哈希表和有序表使用的code展示



04 归并排序及其常见面试题

内容：

归并排序

题目：

归并排序的递归和非递归实现

在一个数组中，一个数左边比它小的数的总和，叫该数的小和
所有数的小和累加起来，叫数组小和
例子： [1,3,4,2,5] 
1左边比1小的数：没有
3左边比3小的数：1
4左边比4小的数：1、3
2左边比2小的数：1
5左边比5小的数：1、3、4、 2
所以数组的小和为1+1+3+1+1+3+4+2=16 
给定一个数组arr，求数组小和

在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为降序对
给定一个数组arr，求数组的降序对总数量

在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然<num，返回总个数
比如：[3,1,7,0,2]
3的后面有：1，0
1的后面有：0
7的后面有：0，2
0的后面没有
2的后面没有
所以总共有5个



05 归并排序面试题(续)、快速排序

内容：

再来一个归并排序面试题

荷兰国旗问题

快速排序1.0

快速排序2.0

快速排序3.0

题目：

给定一个数组arr，两个整数lower和upper，
返回arr中有多少个子数组的累加和在[lower,upper]范围上
Leetcode题目：https://leetcode.com/problems/count-of-range-sum/

荷兰国旗问题的实现

快速排序从1.0到3.0的实现

快速排序的递归实现和非递归实现

code附加，双向链表进行快速排序的code实现



06 比较器、堆结构、堆排序

内容：

比较器

堆结构

堆排序

建立大根堆的两种方式，从上到下、从下到上，及其复杂度分析

题目：

比较器使用的code展示

堆结构的实现

堆排序的实现

已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k
k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。 



07 和堆有关的面试题、加强堆结构

内容：

线段最大重合问题

加强堆的实现

题目：

给定很多线段，每个线段都有两个数[start, end]，
表示线段开始位置和结束位置，左右都是闭区间
规定：
1）线段的开始和结束位置一定都是整数值
2）线段重合区域的长度必须>=1
返回线段最多重合区域中，包含了几条线段

加强堆的实现、注意点解析

做一个加强堆的题目，给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op
两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
arr= [3,3,1,2,1,2,5…
op = [T,T,T,T,F,T,F…
依次表示：
3用户购买了一件商品
3用户购买了一件商品
1用户购买了一件商品
2用户购买了一件商品
1用户退货了一件商品
2用户购买了一件商品
5用户退货了一件商品…
一对arr[i]和op[i]就代表一个事件：
用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
op[i] == F就代表这个用户退货了一件商品
现在你作为电商平台负责人，你想在每一个事件到来的时候，
都给购买次数最多的前K名用户颁奖。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。
得奖系统的规则：
1，如果某个用户购买商品数为0，但是又发生了退货事件，
     则认为该事件无效，得奖名单和上一个事件发生后一致，例子中的5用户
2，某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3，每次都是最多K个用户得奖，K也为传入的参数
      如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4，得奖系统分为得奖区和候选区，任何用户只要购买数>0，
      一定在这两个区域中的一个
5，购买数最大的前K名用户进入得奖区，
      在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6，如果购买数不足以进入得奖区的用户，进入候选区
7，如果候选区购买数最多的用户，已经足以进入得奖区，
     该用户就会替换得奖区中购买数最少的用户（大于才能替换），
     如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户
     如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户
8，候选区和得奖区是两套时间，
     因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有
     从得奖区出来进入候选区的用户，得奖区时间删除，
     进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
     从候选区出来进入得奖区的用户，候选区时间删除，
     进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）
9，如果某用户购买数==0，不管在哪个区域都离开，区域时间删除，
     离开是指彻底离开，哪个区域也不会找到该用户
     如果下次该用户又发生购买行为，产生>0的购买数，
     会再次根据之前规则回到某个区域中，进入区域的时间重记
请遍历arr数组和op数组，遍历每一步输出一个得奖名单
public List<List<Integer>>  topK (int[] arr, boolean[] op, int k)



08 前缀树、不基于比较的排序（计数排序、基数排序）、排序算法的稳定性

内容：

前缀树

计数排序

基数排序

排序算法的稳定性

题目：

前缀树实现

计数排序

基数排序



09 排序算法大总结、链表及其相关面试题

内容：

排序算法总结

排序算法常见的坑

工程上对排序的常见改进

链表面试题的常见技巧

题目：

输入链表头节点，奇数长度返回中点，偶数长度返回上中点
输入链表头节点，奇数长度返回中点，偶数长度返回下中点
输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

给定一个单链表的头节点head，请判断该链表是否为回文结构

给定一个单链表的头节点head，给定一个整数n，将链表按n划分成左边<n、中间==n、右边>n

一种特殊的单链表节点类描述如下 
class Node {
int value; 
Node next; 
Node rand; 
Node(int val) { value = val; } 
} 
rand指针是单链表节点结构中新增的指针，rand可能指向链表中的任意一个节点，也可能指向null
给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表的复制
返回复制的新链表的头节点，要求时间复杂度O(N)，额外空间复杂度O(1) 



10 链表相关面试题（续）、二叉树的常见遍历

内容：

单链表的相交节点系列问题

一种看似高效其实搞笑的节点删除方式

二叉树的中序、先序、后序遍历

题目：

给定两个可能有环也可能无环的单链表，头节点head1和head2
请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交返回null 
要求如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)

能不能不给单链表的头节点，只给想要删除的节点，就能做到在链表上把这个点删掉？

二叉树先序、中序、后序的递归遍历和递归序

二叉树先序、中序、后序的非递归遍历



11 二叉树常见面试题和二叉树的递归套路（上）

内容：

通过题目来熟悉二叉树的解题技巧

题目：

二叉树的按层遍历

二叉树的序列化和反序列化

N叉树如何通过二叉树来序列化、并完成反序列化
Leetcode题目：https://leetcode.com/problems/encode-n-ary-tree-to-binary-tree/

打印二叉树的函数设计

求二叉树的最大宽度

求二叉树某个节点的后继节点
二叉树结构如下定义：
Class Node {
	V value;
	Node left;
	Node right;
	Node parent;
}
给你二叉树中的某个节点，返回该节点的后继节点 

折纸问题
请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开
此时折痕是凹下去的，即折痕突起的方向指向纸条的背面
如果从纸条的下边向上方连续对折2次，压出折痕后展开
此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。 
给定一个输入参数N，代表纸条都从下边向上方连续对折N次
请从上到下打印所有折痕的方向。 
N=1时，打印: down 
N=2时，打印: down down up 



12 二叉树常见面试题和二叉树的递归套路（中）

内容：

通过题目来熟悉二叉树的解题技巧

介绍二叉树的递归套路
1）假设以X节点为头，假设可以向X左树和X右树要任何信息
2）在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要）
3）列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4）把左树信息和右树信息求全集，就是任何一棵子树都需要返回的信息S
5）递归函数都返回S，每一棵子树都这么要求
6）写代码，在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

题目：

判断二叉树是不是搜索二叉树

判断二叉树是不是平衡二叉树

判断二叉树是不是满二叉树

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的大小

给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离



13 二叉树常见面试题和二叉树的递归套路（下）、贪心算法

内容：

二叉树递归套路继续实践

一道贪心算法从头到尾的完整做法

解决贪心题目的重要技巧，即对数器来验证脑洞

再次强调对数器的重要性

题目：

判断二叉树是不是完全二叉树（一般方法解决、递归套路解决）

给定一棵二叉树的头节点head，返回这颗二叉树中最大的二叉搜索子树的头节点

给定一棵二叉树的头节点head，和另外两个节点a和b，返回a和b的最低公共祖先

派对的最大快乐值
 员工信息的定义如下:
class Employee {
    public int happy; // 这名员工可以带来的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}
公司的每个员工都符合 Employee 类的描述。整个公司的人员结构可以看作是一棵标准的、 没有环的多叉树
树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级
叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外每个员工都有一个或多个直接下级
这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：
1.如果某个员工来了，那么这个员工的所有直接下级都不能来
2.派对的整体快乐值是所有到场员工快乐值的累加
3.你的目标是让派对的整体快乐值尽量大
给定一棵多叉树的头节点boss，请返回派对的最大快乐值。

给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中字典序最小的结果



14 贪心算法（续）、并查集

内容：

贪心算法继续实战

并查集详解

题目：

给定一个字符串str，只由'X'和'.'两种字符构成
'X'表示墙，不能放灯，也不需要点亮；'.'表示居民点，可以放灯，需要点亮
如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮
返回如果点亮str中所有需要点亮的位置，至少需要几盏灯

一块金条切成两半，是需要花费和长度数值一样的铜板
比如长度为20的金条，不管怎么切都要花费20个铜板，一群人想整分整块金条，怎么分最省铜板? 
例如，给定数组{10,20,30}，代表一共三个人，整块金条长度为60，金条要分成10，20，30三个部分。
如果先把长度60的金条分成10和50，花费60；再把长度50的金条分成20和30，花费50；一共花费110铜板
但如果先把长度60的金条分成30和30，花费60；再把长度30金条分成10和20，花费30；一共花费90铜板
输入一个数组，返回分割的最小代价

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲，给你每一个项目开始的时间和结束的时间
你来安排宣讲的日程，要求会议室进行的宣讲的场次最多，返回最多的宣讲场次

输入正数数组costs、正数数组profits、正数K和正数M
costs[i]表示i号项目的花费
profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)
K表示你只能串行的最多做k个项目
M表示你初始的资金
说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目，不能并行的做项目。
输出：最后获得的最大钱数

并查集的实现



15 并查集相关的常见面试题

内容：

通过解答实际出现的面试题来体会并查集的优势、熟悉并查集的使用

题目：

一群朋友中，有几个不相交的朋友圈
Leetcode题目：https://leetcode.com/problems/friend-circles/

岛问题（递归解法 + 并查集解法 + 并行解法）
给定一个二维数组matrix，里面的值不是1就是0，上、下、左、右相邻的1认为是一片岛，返回matrix中岛的数量



16 图及其与图相关的算法

内容：

图的表达方式

图的常见描述

图的宽度优先遍历

图的深度优先遍历

图的拓扑排序

最小生成树算法Kruskal

最小生成树算法Prim

单元最短路径算法Dijkstra

题目：

图的数据结构抽象

实现图的宽度优先遍历

实现图的深度优先遍历

三种方式实现图的拓扑排序

用并查集实现Kruskal算法

用堆实现Prim算法

实现Dijkstra算法，用加强堆做更好的实现（16节+17节一开始）



17 用加强堆更好的实现Dijkstra算法、常见的递归

内容：

加强堆实现Dijkstra算法

递归的设计

常见的递归

题目：

打印n层汉诺塔从最左边移动到最右边的全部过程（递归+非递归实现）

打印一个字符串的全部子序列

打印一个字符串的全部子序列，要求不要出现重复字面值的子序列

打印一个字符串的全部排列

打印一个字符串的全部排列，要求不要出现重复的排列

给定一个栈，请逆序这个栈，不能申请额外的数据结构，只能使用递归函数



18 暴力递归到动态规划（一）

内容：

讲述暴力递归和动态规划的关系

记忆化搜索

动态规划都可以由暴力递归改进过来，解决动态规划的套路

常见的尝试模型

设计尝试过程的原则

本节是暴力递归到动态规划的总纲（很重要）

后续的课都是在讲述这一系列的套路

题目：

假设有排成一行的N个位置记为1~N，N一定大于或等于2
开始时机器人在其中的M位置上(M一定是1~N中的一个)
如果机器人来到1位置，那么下一步只能往右来到2位置；
如果机器人来到N位置，那么下一步只能往左来到N-1位置；
如果机器人来到中间位置，那么下一步可以往左走或者往右走；
规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种
给定四个参数 N、M、K、P，返回方法数

给定一个整型数组arr，代表数值不同的纸牌排成一条线
玩家A和玩家B依次拿走每张纸牌
规定玩家A先拿，玩家B后拿
但是每个玩家每次只能拿走最左或最右的纸牌
玩家A和玩家B都绝顶聪明
请返回最后获胜者的分数



19 暴力递归到动态规划（二）

内容：

以18节为总纲

背包问题

记忆化搜索的一个很重要的注意点

通过面试题进一步强化动态规划的解题套路

题目：

背包问题
给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值
给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量
返回能装下的最大价值

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文
arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回需要至少多少张贴纸可以完成这个任务
例子：str= "babac"，arr = {"ba","c","abcd"}
ba + ba + c  3  abcd + abcd 2  abcd+ba 2
所以返回2

给定两个字符串str1和str2，
返回这两个字符串的最长公共子序列长度
比如 ： str1 = “a12b3c456d”,str2 = “1ef23ghi4j56k”
最长公共子序列是“123456”，所以返回长度6



20 暴力递归到动态规划（三）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个字符串str，返回这个字符串的最长回文子序列长度
比如 ： str = “a12b3c43def2ghi1kpm”
最长回文子序列是“1234321”或者“123c321”，返回长度7

请同学们自行搜索或者想象一个象棋的棋盘，
然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置
那么整个棋盘就是横坐标上9条线、纵坐标上10条线的区域
给你三个 参数 x，y，k
返回“马”从(0,0)位置出发，必须走k步
最后落在(x,y)上的方法数有多少种? 

给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间
给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡
只有一台咖啡机，一次只能洗一个杯子，时间耗费a，洗完才能洗下一杯
每个咖啡杯也可以自己挥发干净，时间耗费b，咖啡杯可以并行挥发
假设所有人拿到咖啡之后立刻喝干净，
返回从开始等到所有咖啡机变干净的最短时间
三个参数：int[] arr、int N，int a、int b



21 暴力递归到动态规划（四）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

题目：

给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角
沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和
返回最小距离累加和

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
即便是值相同的货币也认为每一张都是不同的，
返回组成aim的方法数
例如：arr = {1,1,1}，aim = 2
第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2
一共就3种方法，所以返回3

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的方法数
例如：arr = {1,2}，aim = 4
方法如下：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
认为值相同的货币没有任何不同，
返回组成aim的方法数
例如：arr = {1,2,1,1,2,1,2}，aim = 4
方法：1+1+1+1、1+1+2、2+2
一共就3种方法，所以返回3

给定5个参数，N，M，row，col，k
表示在N*M的区域上，醉汉Bob初始在(row,col)位置
Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位
任何时候Bob只要离开N*M的区域，就直接死亡
返回k步之后，Bob还在N*M的区域的概率



22 暴力递归到动态规划（五）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

斜率优化技巧

题目：

给定3个参数，N，M，K
怪兽有N滴血，等着英雄来砍自己
英雄每一次打击，都会让怪兽流失[0~M]的血量
到底流失多少？每一次在[0~M]上等概率的获得一个值
求K次打击之后，英雄把怪兽砍死的概率

arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim。
每个值都认为是一种面值，且认为张数是无限的。
返回组成aim的最少货币数

给定一个正数n，求n的裂开方法数，
规定：后面的数不能比前面的数小
比如4的裂开方法有：
1+1+1+1、1+1+2、1+3、2+2、4
5种，所以返回5



23 暴力递归到动态规划（六）

内容：

以18节为总纲

通过面试题进一步强化动态规划的解题套路

位信息技巧

题目：

给定一个正数数组arr，
请把arr中所有的数分成两个集合，尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

给定一个正数数组arr，请把arr中所有的数分成两个集合
如果arr长度为偶数，两个集合包含数的个数要一样多
如果arr长度为奇数，两个集合包含数的个数必须只差一个
请尽量让两个集合的累加和接近
返回最接近的情况下，较小集合的累加和

N皇后问题是指在N*N的棋盘上要摆N个皇后，
要求任何两个皇后不同行、不同列， 也不在同一条斜线上
给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1
n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0
n=8，返回92



24 窗口内最大值或最小值的更新结构

内容：

滑动窗口

窗口内最大值或最小值的更新结构

用题目来学习窗口内最大值或最小值的更新结构提供的便利性

题目：

窗口内最大值或最小值更新结构的实现
假设一个固定大小为W的窗口，依次划过arr，
返回每一次滑出状况的最大值
例如，arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]

给定一个整型数组arr，和一个整数num
某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，
返回arr中达标子数组的数量

加油站的良好出发点问题

动态规划中利用窗口内最大值或最小值更新结构做优化（难）
arr是货币数组，其中的值都是正数。再给定一个正数aim。
每个值都认为是一张货币，
返回组成aim的最少货币数
注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了



25 单调栈

内容：

单调栈的原理（无重复数+有重复数）

用题目来学习单调栈提供的便利性

题目：

单调栈实现（无重复数+有重复数）

给定一个只包含正数的数组arr，arr中任何一个子数组sub，
一定都可以算出(sub累加和 )* (sub中的最小值)是什么，
那么所有子数组中，这个值最大是多少？

给定一个非负数组arr，代表直方图，返回直方图的最大长方形面积

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的最大子矩形内部有多少个1（面积）

给定一个二维数组matrix，其中的值不是0就是1，返回全部由1组成的子矩形数量



26 单调栈相关的题目（续）、斐波那契数列的矩阵快速幂模型

内容：

再讲一个单调栈相关的面试题

斐波那契数列的矩阵快速幂模型详解

题目：

给定一个数组arr，返回所有子数组最小值的累加和

斐波那契数列矩阵乘法方式的实现

台阶方法数问题
一个人可以一次往上迈1个台阶，也可以迈2个台阶，返回迈上N级台阶的方法数

奶牛生小牛问题
第一年农场有1只成熟的母牛A，往后的每年：
1）每一只成熟的母牛都会生一只母牛
2）每一只新出生的母牛都在出生的第三年成熟
3）每一只母牛永远不会死
返回N年后牛的数量

给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串
如果某个字符串，任何0字符的左边都有1紧挨着，认为这个字符串达标
返回有多少达标的字符串

用1*2的瓷砖，把N*2的区域填满，返回铺瓷砖的方法数



27 KMP算法

内容：

KMP算法

和KMP算法相关的面试题

题目：

KMP算法实现

给定两棵二叉树的头节点head1和head2，返回head1中是否有某个子树的结构和head2完全一样

判断str1和str2是否互为旋转字符串



28 Manacher算法

内容：

Manacher算法

和Manacher算法相关的面试题

题目：

Manacher算法实现

给定一个字符串str，只能在str的后面添加字符，想让str整体变成回文串，返回至少要添加几个字符



29 在无序数组中找到第K小的数、蓄水池算法

内容：

时间复杂度O(N)可以解决在无序数组中找到第K小的数，这个经典的面试题

改写快排的partition方法

bfprt算法

蓄水池算法

题目：

在无序数组中找到第K小的数（改写快排+bfprt）

设计在无序数组中收集最大的前K个数字的算法（根据不同的三个时间复杂度，设计三个算法）
给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：
1）O(N*logN)
2）O(N + K*logN)
3）O(n + k*logk)

蓄水池算法实现
假设有一个源源吐出不同球的机器，
只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉
如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里




30 二叉树的Morris遍历

内容：

二叉树之前的遍历方式有空间浪费的问题

Morris遍历时间复杂度O(N)，额外空间复杂度O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的

假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，
	然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，
	然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

Morris遍历实现二叉树的先序、中序、后序遍历

题目：

Morris遍历的实现

给定一棵二叉树的头节点head，求以head为头的树中，最小深度是多少？



31 线段树

内容：

线段树是一种支持范围整体修改和范围整体查询的数据结构

线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况

题目：

给定一个数组arr，用户希望你实现如下三个方法
1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
怎么让这三个方法，时间复杂度都是O(logN)

想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线
下面是这个游戏的简化版：
1）只会下落正方形积木
2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落
3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的
4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。
给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，
返回每一次掉落之后的最大高度
Leetcode题目：https://leetcode.com/problems/falling-squares/



32 IndexTree、AC自动机

内容：

IndexTree
1）支持区间查询
2）没有线段树那么强，但是非常容易改成一维、二维、三维的结构
3）只支持单点更新

AC自动机
解决在一个大字符串中，找到多个候选字符串的问题
1）把所有匹配串生成一棵前缀树
2）前缀树节点增加fail指针
3）fail指针的含义：如果必须以当前字符结尾，当前形成的路径是str，剩下哪一个字符串的前缀和str的后缀
   拥有最大的匹配长度。fail指针就指向那个字符串的最后一个字符所对应的节点（迷不迷？听讲述！）

题目：

IndexTree在一维数组和二维数组上的实现

AC自动机的实现



33 与哈希函数有关的结构

内容：

哈希函数

哈希函数的应用

布隆过滤器

一致性哈希

题目：

原理讲述为主，面试只会聊设计，所以本节无题目



34 资源限制类题目的解题套路

内容：

布隆过滤器用于集合的建立与查询，并可以节省大量空间
一致性哈希解决数据服务器的负载管理问题
利用并查集结构做岛问题的并行计算
哈希函数可以把数据按照种类均匀分流
位图解决某一范围上数字的出现情况，并可以节省大量空间
利用分段统计思想、并进一步节省大量空间
利用堆、外排序来做多个处理单元的结果合并

题目：

32位无符号整数的范围是0~4,294,967,295，
现在有一个正好包含40亿个无符号整数的文件，
可以使用最多1GB的内存，怎么找到出现次数最多的数？

32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，
所以在整个范围中必然存在没出现过的数，可以使用最多1GB的内存，怎么找到所有未出现过的数？
进阶：内存限制为 3KB，但是只用找到一个没出现过的数即可

有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
补充：某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数

32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？

32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，
整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果



35 有序表（上）

内容：

平衡搜索二叉树

左旋

右旋

AVL树的节点违规4种类型（LL，LR，RL，RR）

题目：

AVL树的实现



36 有序表（中）

内容：

size-balanced-tree详解

skiplist详解

聊聊红黑树

题目：

size-balanced-tree实现

skiplist实现



37 有序表（下）

内容：

讲解有序表相关的面试题

讲解改写有序表的题目核心点

题目：

给定一个数组arr，和两个整数a和b（a<=b）。求arr中有多少个子数组，累加和在[a,b]这个范围上。返回达标的子数组数量

有一个滑动窗口：
1）L是滑动窗口最左位置、R是滑动窗口最右位置，一开始LR都在数组左侧
2）任何一步都可能R往右动，表示某个数进了窗口
3）任何一步都可能L往右动，表示某个数出了窗口
想知道每一个窗口状态的中位数

设计一个结构包含如下两个方法：
void add(int index, int num)：把num加入到index位置
int get(int index) ：取出index位置的值
void remove(int index) ：把index位置上的值删除
要求三个方法时间复杂度O(logN)

假设有打乱顺序的一群人站成一个队列，数组people表示队列中一些人的属性（不一定按顺序）
每个people[i]=[hi, ki]表示第i个人的身高为hi，前面正好有ki个身高大于或等于hi的人
请你重新构造并返回输入数组people所表示的队列，返回的队列应该格式化为数组queue
其中queue[j]=[hj, kj]是队列中第j个人的属性（queue[0] 是排在队列前面的人）。
Leetcode题目：https://leetcode.com/problems/queue-reconstruction-by-height/



38 根据对数器找规律、根据数据量猜解法

内容：

讲解对数器找规律的解题技巧

讲解根据数据量猜解法的技巧
1）C/C++，1秒处理的指令条数为10的8次方
2）Java等语言，1~4秒处理的指令条数为10的8次方
3）这里就有大量的分析提示了


题目：

小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，
且使用的每个袋子必须装满，给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草
不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方)
谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数N，返回谁会赢

定义一种数：可以表示成若干（数量>1）连续正数和的数
比如，5=2+3，5就是这样的数；12=3+4+5，12就是这样的数
2=1+1，2不是这样的数，因为等号右边不是连续正数
给定一个参数N，返回是不是可以表示成若干连续正数和的数

int[] d，d[i]：i号怪兽的能力
int[] p，p[i]：i号怪兽要求的钱
开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。
如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力
你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你
他的能力直接累加到你的能力上
返回通过所有的怪兽，需要花的最小钱数
（课上会给出不同的数据量描述）



39 根据数据量猜解法（续）、分治技巧、卡特兰数

内容：

继续熟悉根据数据量猜解法

讲解分治法

讲解卡特兰数（课上证明的时候有小错，在40节开始处修正了）

题目：

给定一个非负数组arr，和一个正数m，返回arr的所有子序列中累加和%m之后的最大值

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w，牛牛想知道在总体积不超过背包容量的情况下,
一共有多少种零食放法，体积为0也算一种放法
1 <= n <= 30, 1 <= w <= 2 * 10^9，v[I] (0 <= v[i] <= 10^9）

假设给你N个0，和N个1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1的数量都不少于0的数量

有N个二叉树节点，每个节点彼此之间无任何差别，返回由N个二叉树节点，组成的不同结构数量是多少？

题目补充：	arr中的值可能为正，可能为负，可能为0，自由选择arr中的数字，能不能累加得到sum（多种做法）



40 子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题

内容：

修正了39节卡特兰数讲解时的一个小错误

熟悉子数组达到规定累加和的三个模型（正、有正有负有0、累加和<=K）

矩阵处理技巧的宏观调度coding技巧

题目：

给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K
并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K
找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

给定一个正方形矩阵matrix，原地调整成顺时针90度转动的样子

给定一个正方形或者长方形矩阵matrix，实现转圈打印

给定一个正方形或者长方形矩阵matrix，实现zigzag打印

转圈打印星号*问题



41 四边形不等式技巧（上）

内容：

区间划分问题中的划分点不回退现象

四边形不等式技巧特征
1，两个可变参数的区间划分问题
2，每个格子有枚举行为
3，当两个可变参数固定一个，另一个参数和答案之间存在单调性关系
4，而且两组单调关系是反向的：(升 升，降 降)  (升 降，降 升)
5，能否获得指导枚举优化的位置对：上+右，或者，左+下

四边形不等式技巧注意点
1，不要证明！用对数器验证！
2，枚举的时候面对最优答案相等的时候怎么处理？用对数器都试试！
3，可以把时间复杂度降低一阶
O(N^3) -> O(N^2)
O(N^2 * M) -> O(N * M) 
O(N * M^2) -> O(N * M) 
4，四边形不等式有些时候是最优解，有些时候不是
不是的原因：尝试思路，在根儿上不够好

题目：

给定一个非负数组arr，长度为N，
那么有N-1种方案可以把arr切成左右两部分
每一种方案都有，min{左部分累加和，右部分累加和}
求这么多方案中，min{左部分累加和，右部分累加和}的最大值是多少？
整个过程要求时间复杂度O(N)

把题目一中提到的，min{左部分累加和，右部分累加和}，定义为S(N-1)，也就是说：
S(N-1)：在arr[0…N-1]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
现在要求返回一个长度为N的s数组，
s[i] =在arr[0…i]范围上，做最优划分所得到的min{左部分累加和，右部分累加和}的最大值
得到整个s数组的过程，做到时间复杂度O(N)

摆放着n堆石子。现要将石子有次序地合并成一堆，规定每次只能选相邻的2堆石子合并成新的一堆
并将新的一堆石子数记为该次合并的得分，求出将n堆石子合并成一堆的最小得分（或最大得分）合并方案

给定一个整型数组 arr，数组中的每个值都为正数，表示完成一幅画作需要的时间，再给定一个整数num
表示画匠的数量，每个画匠只能画连在一起的画作
所有的画家并行工作，返回完成所有的画作需要的最少时间
arr=[3,1,4]，num=2。
最好的分配方式为第一个画匠画3和1，所需时间为4
第二个画匠画4，所需时间为4
所以返回4
arr=[1,1,1,4,3]，num=3
最好的分配方式为第一个画匠画前三个1，所需时间为3
第二个画匠画4，所需时间为4
第三个画匠画3，所需时间为3
返回4



42 四边形不等式技巧（下）

内容：

继续熟悉四边形不等式

展示好的尝试是最关键的

题目：

一条直线上有居民点，邮局只能建在居民点上
给定一个有序正数数组arr，每个值表示 居民点的一维坐标，再给定一个正数 num，表示邮局数量
选择num个居民点建立num个邮局，使所有的居民点到最近邮局的总距离最短，返回最短的总距离
arr=[1,2,3,4,5,1000]，num=2
第一个邮局建立在3位置，第二个邮局建立在1000位置
那么1位置到邮局的距离为2，2位置到邮局距离为1，3位置到邮局的距离为0，4位置到邮局的距离为1，5位置到邮局的距离为2
1000位置到邮局的距离为0
这种方案下的总距离为6，其他任何方案的总距离都不会比该方案的总距离更短，所以返回6

一座大楼有0~N层，地面算作第0层，最高的一层为第N层
已知棋子从第0层掉落肯定不会摔碎，从第i层掉落可能会摔碎，也可能不会摔碎(1≤i≤N)
给定整数N作为楼层数，再给定整数K作为棋子数
返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下扔的最少次数
一次只能扔一个棋子
N=10，K=1
返回10
因为只有1棵棋子，所以不得不从第1层开始一直试到第10层
在最差的情况下，即第10层是不会摔坏的最高层，最少也要扔10次
N=3，K=2
返回2
先在2层扔1棵棋子，如果碎了试第1层，如果没碎试第3层
N=105，K=2
返回14
第一个棋子先在14层扔，碎了则用仅存的一个棋子试1~13
若没碎，第一个棋子继续在27层扔，碎了则用仅存的一个棋子试15~26
若没碎，第一个棋子继续在39层扔，碎了则用仅存的一个棋子试28~38
若没碎，第一个棋子继续在50层扔，碎了则用仅存的一个棋子试40~49
若没碎，第一个棋子继续在60层扔，碎了则用仅存的一个棋子试51~59
若没碎，第一个棋子继续在69层扔，碎了则用仅存的一个棋子试61~68
若没碎，第一个棋子继续在77层扔，碎了则用仅存的一个棋子试70~76
若没碎，第一个棋子继续在84层扔，碎了则用仅存的一个棋子试78~83
若没碎，第一个棋子继续在90层扔，碎了则用仅存的一个棋子试85~89
若没碎，第一个棋子继续在95层扔，碎了则用仅存的一个棋子试91~94
若没碎，第一个棋子继续在99层扔，碎了则用仅存的一个棋子试96~98
若没碎，第一个棋子继续在102层扔，碎了则用仅存的一个棋子试100、101
若没碎，第一个棋子继续在104层扔，碎了则用仅存的一个棋子试103
若没碎，第一个棋子继续在105层扔，若到这一步还没碎，那么105便是结果



43 状态压缩的动态规划

内容：

动态规划的状态压缩技巧

题目：

在"100 game"这个游戏中，两名玩家轮流选择从1到10的任意整数，累计整数和
先使得累计整数和达到或超过100的玩家，即为胜者，如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？
例如，两个玩家可以轮流从公共整数池中抽取从1到15的整数（不放回），直到累计整数和 >= 100
给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和）
判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）
你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。
Leetcode题目：https://leetcode.com/problems/can-i-win/

TSP问题
有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0
所有点到点的距离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示
现要求一旅行商从k城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城
参数给定一个matrix，给定k。返回总距离最短的路的距离

铺砖问题（最优解其实是轮廓线dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）
你有无限的1*2的砖块，要铺满M*N的区域，
不同的铺法有多少种?



44 DC3生成后缀数组详解

内容：

后缀数组

介绍用DC3算法生成后缀数组的流程

题目：

给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串
Leetcode题目：https://leetcode.com/problems/last-substring-in-lexicographical-order/

DC3算法的实现（完全根据论文描述）



45 后缀数组解决的面试题

内容：

通过题目进一步熟悉DC3算法

通过DC3算法得到height数组

题目：

给定两个字符串str1和str2，想把str2整体插入到str1中的某个位置，形成最大的字典序，返回字典序最大的结果

给两个长度分别为M和N的整型数组nums1和nums2，其中每个值都不大于9，再给定一个正数K。 你可以在nums1和nums2中挑选数字，要求一共挑选K个，并且要从左到右挑。返回所有可能的结果中，代表最大数字的结果

最长公共子串问题是面试常见题目之一，假设str1长度N，str2长度M
一般在面试场上回答出O(N*M)的解法已经是比较优秀了
因为得到O(N*M)的解法，就已经需要用到动态规划了
但其实这个问题的最优解是O(N+M)，需要用到后缀数组+height数组
课上将对本题解法代码进行详解



46 动态规划猜法中和外部信息简化的相关问题（上）、哈夫曼树

内容：

以18节做总纲

有些动态规划面试题，需要很好的设计参数，这种设计方式都有"外部信息简化"的特征

哈夫曼树

题目：

有n个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中
现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1] 枚硬币
这里的i-1和i+1代表和i相邻的、没有被戳爆的！两个气球的序号
如果i-1或i+1超出了数组的边界，那么就当它是一个数字为1的气球
求所能获得硬币的最大数量
Leetcode题目：https://leetcode.com/problems/burst-balloons/

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子
直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续k个盒子（k >= 1）
这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和
Leetcode题目：https://leetcode.com/problems/remove-boxes/

如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉
比如:"ab"，其中a和b都不能被消掉
如果一个字符相邻的位置有相同字符，就可以一起消掉
比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac"
某些字符如果消掉了，剩下的字符认为重新靠在一起
给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量
比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1
但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。
再比如："baaccabb"，
如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，最后消除最右侧的两个b，剩下"ba"无法再消除，返回2
而最优策略是：
如果先消除中间的两个c，剩下"baaabb"，如果再消除中间的三个a，剩下"bbb"，最后消除三个b，不留下任何字符，返回0，这才是最优解

给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和

哈夫曼树的实现



47 动态规划猜法中和外部信息简化的相关问题（下）、最大网络流算法之Dinic算法

内容：

进一步解决带有"外部信息简化"特征的动态规划

Dinic算法

题目：

有台奇怪的打印机有以下两个特殊要求：
打印机每次只能打印由同一个字符组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串s，你的任务是计算这个打印机打印它需要的最少打印次数。
Leetcode题目：https://leetcode.com/problems/strange-printer/

整型数组arr长度为n(3 <= n <= 10^4)，最初每个数字是<=200的正数且满足如下条件：
1. 0位置的要求：arr[0]<=arr[1] 
2. n-1位置的要求：arr[n-1]<=arr[n-2]
3. 中间i位置的要求：arr[i]<=max(arr[i-1],arr[i+1]) 
但是在arr有些数字丢失了，比如k位置的数字之前是正数，丢失之后k位置的数字为0
请你根据上述条件，计算可能有多少种不同的arr可以满足以上条件
比如 [6,0,9] 只有还原成 [6,9,9]满足全部三个条件，所以返回1，即[6,9,9]达标

Dinic算法详解
测试链接：https://lightoj.com/problem/internet-bandwidth



======================================================================================================================================



01 大厂高频算法和数据结构面试题1

题目：

给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？
即使绳子边缘处盖住点也算盖住

给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算

给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方

一个数组中只有两种字符'G'和'B'，可以让所有的G都放在左侧，所有的B都放在右侧
或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在相邻字符之间进行交换操作，返回至少需要交换几次

给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，返回能走出来的最长的递增链长度

给定两个非负数组x和hp，长度都是N，再给定一个正数range
x有序，x[i]表示i号怪兽在x轴上的位置
hp[i]表示i号怪兽的血量
再给定一个正数range，表示如果法师释放技能的范围长度
被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？

给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target
请问最后算出target的方法数



02 大厂高频算法和数据结构面试题2

题目：

给定数组hard和money，长度都为N，hard[i]表示i号工作的难度， money[i]表示i号工作的收入
给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样
但是人的能力必须>=这份工作的难度，才能上班。返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入

贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额
一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则
需要购买的可乐数量是m，其中手头拥有的10、50、100的数量分别为a、b、c，可乐的价格是x(x是10的倍数)
请计算出需要投入硬币次数

已知一个消息流会不断地吐出整数1~N，但不一定按照顺序依次吐出，如果上次打印的序号为i， 那么当i+1出现时
请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构

现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为income[i][0]，去B可得收入为income[i][1]
返回能使所有司机总收入最高的方案是多少钱?

设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)

给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序，返回满足这一设定的子数组中最短的是多长



03 大厂高频算法和数据结构面试题3

题目：

求一个字符串中，最长无重复字符子串长度

只由小写字母（a~z）组成的一批字符串，都放在字符类型的数组String[] arr中，如果其中某两个字符串所含有的字符种类完全一样
就将两个字符串算作一类，比如baacbba和bac就算作一类，返回arr中有多少类

给定一个只有0和1组成的二维数组，返回边框全是1（内部无所谓）的最大正方形面积

给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛
一局比赛只有两个人，返回最多可以同时有多少场比赛

给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重
想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数

给定整数数组nums和目标值goal，需要从nums中选出一个子序列，使子序列元素总和最接近goal
也就是说如果子序列元素和为sum ，需要最小化绝对差abs(sum - goal)，返回 abs(sum - goal)可能的最小值
注意数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。

电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门
给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数
最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符
旋转 ring 拼出 key 字符 key[i] 的阶段中：
您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
Leetcode题目：https://leetcode.com/problems/freedom-trail/

给定三个参数，二叉树的头节点head，树上某个节点target，正数K。从target开始，可以向上走或者向下走，返回与target的距离是K的所有节点



04 大厂高频算法和数据结构面试题4

题目：

数组为{3, 2, 2, 3, 1}，查询为(0, 3, 2)，意思是在数组里下标0~3这个范围上，有几个？答案返回2
假设给你一个数组arr，对这个数组的查询非常频繁，且都给了查询组，请返回所有查询的结果

返回一个数组中子数组最大累加和

返回一个二维数组中子矩阵最大累加和

返回一个数组中所选数字不能相邻的情况下最大子序列累加和

老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分
你需要按照以下要求，帮助老师给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，返回老师至少需要准备多少颗糖果
进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果

生成长度为size的达标数组，什么叫达标？对于任意的i<k<j，满足[i]+[j]!=[k]*2。给定一个正数size，返回长度为size的达标数组

给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的
Leetcode题目：https://leetcode.com/problems/interleaving-string/

大楼轮廓线问题
Leetcode题目：https://leetcode.com/problems/the-skyline-problem/



05 大厂高频算法和数据结构面试题5

题目：

已知一棵搜索二叉树上没有重复值的节点，现在有一个数组arr，是这棵搜索二叉树先序遍历的结果，请根据arr生成整棵树并返回头节点

如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树

编辑距离问题

给定两个字符串s1和s2，问s2最少删除多少字符可以成为s1的子串？比如 s1 = "abcde"，s2 = "axbc"，s2删掉'x'即可，返回1



06 大厂高频算法和数据结构面试题6

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，返回arr的最大子数组异或和

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，想知道arr中哪两个数的异或结果最大，返回最大的异或结果
Leetcode题目：https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/

给定一个非负整数组成的数组nums。另有一个查询数组queries，其中queries[i]=[xi, mi]
第i个查询的答案是xi和任何nums数组中不超过mi的元素按位异或（XOR）得到的最大值
换句话说，答案是max(nums[j] XOR xi)，其中所有j均满足nums[j]<= mi。如果nums中的所有元素都大于mi，最终答案就是-1
返回一个整数数组answer作为查询的答案，其中answer.length==queries.length且answer[i]是第i个查询的答案
Leetcode题目：https://leetcode.com/problems/maximum-xor-with-an-element-from-array/

数组中所有数都异或起来的结果，叫做异或和。给定一个数组arr，可以任意切分成若干个不相交的子数组。其中一定存在一种最优方案，使得切出异或和为0的子数组最多，返回这个最多数量

Nim博弈，给定一个正数数组arr，先手和后手每次可以选择在一个位置拿走若干值，这个值要大于0，但是要小于该处的剩余，谁最先拿空arr谁赢，根据arr返回谁赢



07 大厂高频算法和数据结构面试题7

给定一个非负数组成的数组，长度一定大于1，想知道数组中哪两个数&的结果最大，返回这个最大结果。要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个二叉树，我们在树的节点上安装摄像头，节点上的每个摄影头都可以监视其父对象、自身及其直接子对象，计算监控树的所有节点所需的最小摄像头数量

给定一个数组arr，返回如果排序之后（注意是如果排序），相邻两数的最大差值。要求时间复杂度O(N)，不能使用非基于比较的排序

给定一个有序数组arr，其中值可能为正、负、0。返回arr中每个数都平方之后不同的结果有多少种？
给定一个数组arr，先递减然后递增，返回arr中有多少个不同的数字？

假设所有字符都是小写字母，大字符串是str，arr是去重的单词表, 每个单词都不是空字符串且可以使用任意次。使用arr中的单词有多少种拼接str的方式，返回方法数。

String str, int K, String[] parts, int[] record
Parts和records的长度一样长，str一定要分割成k个部分，分割出来的每部分在parts里必须得有，那一部分的得分在record里，请问str切成k个部分，返回最大得分



08 大厂高频算法和数据结构面试题8

给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘除符号和左右括号。返回公式的计算结果
难点在于括号可能嵌套很多层，str="48*((70-65)-43)+8*1"，返回-1816。str="3+1*4"，返回7。str="3+(1*4)"，返回7。
1，可以认为给定的字符串一定是正确的公式，即不需要对str做公式有效性检查
2，如果是负数，就需要用括号括起来，比如"4*(-3)"但如果负数作为公式的开头或括号部分的开头，则可以没有括号，比如"-3*4"和"(-3*4)"都是合法的
3，不用考虑计算过程中会发生溢出的情况。

给定n个非负整数a1，a2，...an，每个数代表坐标中的一个点 (i, ai)。在坐标内画n条垂直线
垂直线i的两个端点分别为(i, ai)和(i, 0)，找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水
Leetcode题目：https://leetcode.com/problems/container-with-most-water/

给定一个char[][] matrix，也就是char类型的二维数组，再给定一个字符串word，
可以从任何一个某个位置出发，可以走上、下、左、右，能不能找到word？
 char[][] m = {  { 'a', 'b', 'z' }, 
                 { 'c', 'd', 'o' }, 
                 { 'f', 'e', 'o' } }
设定1：可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是可以找到的，z -> o -> o -> o -> z，因为允许走一条路径中已经走过的字符
设定2：不可以走重复路的情况下，返回能不能找到
比如，word = "zoooz"，是不可以找到的，因为允许走一条路径中已经走过的字符不能重复走 

给定一个矩阵matrix，值有正、负、0。蛇可以空降到最左列的任何一个位置，初始增长值是0。蛇每一步可以选择右上、右、右下三个方向的任何一个前进
沿途的数字累加起来，作为增长值；但是蛇一旦增长值为负数，就会死去。蛇有一种能力，可以使用一次：把某个格子里的数变成相反数
蛇可以走到任何格子的时候停止，返回蛇能获得的最大增长值



09 大厂高频算法和数据结构面试题9

题目：

给定一个数组arr，长度为N，arr中的值不是0就是1。arr[i]表示第i栈灯的状态，0代表灭灯，1代表亮灯
每一栈灯都有开关，但是按下i号灯的开关，会同时改变i-1、i、i+1栈灯的状态
问题一：如果N栈灯排成一条直线,请问最少按下多少次开关？
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关只能影响0和1位置的灯
N-1号灯的开关只能影响N-2和N-1位置的灯
问题二：如果N栈灯排成一个圈,请问最少按下多少次开关,能让灯都亮起来
i为中间位置时，i号灯的开关能影响i-1、i和i+1
0号灯的开关能影响N-1、0和1位置的灯
N-1号灯的开关能影响N-2、N-1和0位置的灯

给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。答案可以按任意顺序返回
Leetcode题目：https://leetcode.com/problems/remove-invalid-parentheses/

给定一个数组arr，求最长递增子序列长度
Leetcode题目：https://leetcode.com/problems/longest-increasing-subsequence

给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度
当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样
请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）
注意：不允许旋转信封

定义何为step sum？比如680，680 + 68 + 6 = 754，680的step sum叫754。给定一个正数num，判断它是不是某个数的step sum



10 大厂高频算法和数据结构面试题10

题目：

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

Top K Frequent Words II
Implement three methods for Topk Class:
TopK(k). The constructor.
add(word). Add a new word.
topk(). Get the current top k frequent words.
LintCode题目：https://www.lintcode.com/problem/550/

给出两个整数n和k，找出所有包含从1到n的数字，且恰好拥有k个逆序对的不同的数组的个数
逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对，否则不是
由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值
Leetcode题目：https://leetcode.com/problems/k-inverse-pairs-array/

给定一棵搜索二叉树头节点，转化成首尾相接的有序双向链表（节点都有两个方向的指针）

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。
Leetcode题目：https://leetcode-cn.com/problems/boolean-evaluation-lcci/



11 大厂高频算法和数据结构面试题11

题目：

问题一：一个字符串至少需要添加多少个字符能整体变成回文串
问题二：返回问题一的其中一种添加结果
问题三：返回问题一的所有添加结果

问题一：一个字符串至少要切几刀能让切出来的子串都是回文串
问题二：返回问题一的其中一种划分结果
问题三：返回问题一的所有划分结果



12 大厂高频算法和数据结构面试题12

题目：

给定长度为m的字符串aim，以及一个长度为n的字符串str，问能否在str中找到一个长度为m的连续子串，
使得这个子串刚好由aim的m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数
进阶，在两个都有序的数组中找整体第K小的数，可以做到O(log(Min(M,N)))

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。
返回p能否匹配s



13 大厂高频算法和数据结构面试题13

题目：

谷歌面试题扩展版，面值为1~N的牌组成一组，每次你从组里等概率的抽出1~N中的一张，下次抽会换一个新的组，有无限组
当累加和<a时，你将一直抽牌；当累加和>=a且<b时，你将获胜；当累加和>=b时，你将失败
返回获胜的概率，给定的参数为N，a，b

假设有 n 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的
在每一步操作中，你可以选择任意 m （1 ≤ m ≤ n） 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机
给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的最少的操作步数
如果不能使每台洗衣机中衣物的数量相等，则返回-1
Leetcode题目：https://leetcode.com/problems/super-washing-machines/

旋变字符串
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s ，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 。
Leetcode题目：https://leetcode.com/problems/scramble-string/

有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：
一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块稳定不会掉落时
给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，对应位置的砖块（若存在）会消失
然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）
返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目
注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
Leetcode题目：https://leetcode.com/problems/bricks-falling-when-hit/



14 大厂高频算法和数据结构面试题14

题目：

给定一个只由左括号和右括号的字符串，返回最长的有效括号子串的长度

arr中求子数组的累加和是<=K的并且是最大的，返回这个最大的累加和

从二叉树的某个节点x开始，往下子节点都要的，叫子树；在二叉树上只要能连起来的任何结构，叫子拓扑结构；
返回二叉树上满足搜索二叉树性质的、最大子拓扑结构的节点数

给定一个棵完全二叉树，返回这棵树的节点个数，要求时间复杂度小于O(树的节点数)

给定一个棵搜索二叉树的头节点head，其中有两个节点错了，交换过来就能让整棵树重新变成搜索二叉树，怎么找到并调整正确？
Leetcode题目：https://leetcode.com/problems/recover-binary-search-tree/

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。
 


15 大厂高频算法和数据结构面试题15

题目：股票系列问题

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/



16 大厂高频算法和数据结构面试题16

题目：

给定一个有正、有负、有0的数组arr，
给定一个整数k，
返回arr的子集是否能累加出k
1）正常怎么做？
2）如果arr中的数值很大，但是arr的长度不大，怎么做？

给定一个正数数组arr，
返回arr的子集不能累加出的最小正数
1）正常怎么做？
2）如果arr中肯定有1这个值，怎么做？

给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，
使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示，请输出满足上述要求的最少需要补充的数字个数

给定整数power，给定一个数组arr，给定一个数组reverse。含义如下：
arr的长度一定是2的power次方，reverse中的每个值一定都在0~power范围。
例如power = 2, arr = {3, 1, 4, 2}，reverse = {0, 1, 0, 2}
任何一个在前的数字可以和任何一个在后的数组，构成一对数。可能是升序关系、相等关系或者降序关系。
比如arr开始时有如下的降序对：(3,1)、(3,2)、(4,2)，一共3个。
接下来根据reverse对arr进行调整：
reverse[0] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[3,1,4,2]，此时有3个逆序对。
reverse[1] = 1, 表示在arr中，划分每2(2的1次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对
reverse[2] = 0, 表示在arr中，划分每1(2的0次方)个数一组，然后每个小组内部逆序，那么arr变成[1,3,2,4]，此时有1个逆序对。
reverse[3] = 2, 表示在arr中，划分每4(2的2次方)个数一组，然后每个小组内部逆序，那么arr变成[4,2,3,1]，此时有4个逆序对。
所以返回[3,1,1,4]，表示每次调整之后的逆序对数量。
输入数据状况：
power的范围[0,20]
arr长度范围[1,10的7次方]
reverse长度范围[1,10的6次方]

约瑟夫环问题
给定一个链表头节点head，和一个正数m，从头开始，每次数到m就杀死当前节点，然后被杀节点的下一个节点从1开始重新数，周而复始直到只剩一个节点，返回最后的节点
Leetcode题目：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/



17 大厂高频算法和数据结构面试题17

题目：

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个数num，返回二维数组中有没有num这个数

给定一个每一行有序、每一列也有序，整体可能无序的二维数组，再给定一个正数k，返回二维数组中第k小的数
Leetcode题目：https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/

给定一个字符串数组arr，里面都是互不相同的单词，找出所有不同的索引对(i, j)，使得列表中的两个单词，words[i] + words[j]，可拼接成回文串。
Leetcode题目：https://leetcode.com/problems/palindrome-pairs/

给定两个字符串S和T，返回S的所有子序列中有多少个子序列的字面值等于T

给定一个字符串str，返回str的所有子序列中有多少不同的字面值
Leetcode题目：https://leetcode.com/problems/distinct-subsequences-ii/



18 大厂高频算法和数据结构面试题18

题目：

给定一个数组arr，长度为N，arr中的值只有1，2，3三种
arr[i] == 1，代表汉诺塔问题中，从上往下第i个圆盘目前在左
arr[i] == 2，代表汉诺塔问题中，从上往下第i个圆盘目前在中
arr[i] == 3，代表汉诺塔问题中，从上往下第i个圆盘目前在右
那么arr整体就代表汉诺塔游戏过程中的一个状况，如果这个状况不是汉诺塔最优解运动过程中的状况，返回-1
如果这个状况是汉诺塔最优解运动过程中的状态，返回它是第几个状态

在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。
返回必须翻转的 0 的最小数目。（可以保证答案至少是1）
Leetcode题目：https://leetcode.com/problems/shortest-bridge/

给定一个矩阵matrix，先从左上角开始，每一步只能往右或者往下走，走到右下角。然后从右下角出发，每一步只能往上或者往左走，再回到左上角。任何一个位置的数字，只能获得一遍。返回最大路径和。
输入描述:
第一行输入两个整数M和N，M,N<=200
接下来M行，每行N个整数，表示矩阵中元素
输出描述:
输出一个整数，表示最大路径和
牛客网题目：https://www.nowcoder.com/questionTerminal/8ecfe02124674e908b2aae65aad4efdf

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组，按照降序输出
时间复杂度为O(klogk)
输入描述：
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
输出描述：
输出K个整数表示答案
牛客网题目：https://www.nowcoder.com/practice/7201cacf73e7495aa5f88b223bbbf6d1



19 大厂高频算法和数据结构面试题19

题目：

LRU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lru-cache/

LFU内存/缓存替换算法
Leetcode题目：https://leetcode.com/problems/lfu-cache/

给定一个正数N，比如N = 13，在纸上把所有数都列出来如下：
1 2 3 4 5 6 7 8 9 10 11 12 13
可以数出1这个字符出现了6次，给定一个正数N，如果把1~N都列出来，返回1这个字符出现的多少次

你有k个非递减排列的整数列表。找到一个最小区间，使得k个列表中的每个列表至少有一个数包含在其中
我们定义如果 b-a < d-c 或者在 b-a == d-c 时 a < c，则区间 [a,b] 比 [c,d] 小。
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

一张扑克有3个属性，每种属性有3种值（A、B、C）
比如"AAA"，第一个属性值A，第二个属性值A，第三个属性值A
比如"BCA"，第一个属性值B，第二个属性值C，第三个属性值A
给定一个字符串类型的数组cards[]，每一个字符串代表一张扑克
从中挑选三张扑克，一个属性达标的条件是：这个属性在三张扑克中全一样，或全不一样
挑选的三张扑克达标的要求是：每种属性都满足上面的条件
比如："ABC"、"CBC"、"BBC"
第一张第一个属性为"A"、第二张第一个属性为"C"、第三张第一个属性为"B"，全不一样
第一张第二个属性为"B"、第二张第二个属性为"B"、第三张第二个属性为"B"，全一样
第一张第三个属性为"C"、第二张第三个属性为"C"、第三张第三个属性为"C"，全一样
每种属性都满足在三张扑克中全一样，或全不一样，所以这三张扑克达标
返回在cards[]中任意挑选三张扑克，达标的方法数



20 大厂高频算法和数据结构面试题20

题目：

如果只给定一个二叉树前序遍历数组pre和中序遍历数组in，能否不重建树，而直接生成这个二叉树的后序数组并返回，已知二叉树中没有重复值

给定一个由不同正整数的组成的非空数组 A，考虑下面的图：有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；
只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。返回图中最大连通集合的大小
Leetcode题目：https://leetcode.com/problems/largest-component-size-by-common-factor/

完美洗牌问题
给定一个长度为偶数的数组arr，假设长度为N*2
左部分：arr[L1...Ln] 右部分： arr[R1...Rn]
请把arr调整成arr[L1,R1,L2,R2,L3,R3,...,Ln,Rn]
要求时间复杂度O(N)，额外空间复杂度O(1)

给定一个字符串str，当然可以生成很多子序列，返回有多少个子序列是回文子序列，空序列不算回文
比如，str = “aba”，回文子序列：{a}、{a}、 {a,a}、 {b}、{a,b,a}，返回5



21 大厂高频算法和数据结构面试题21

题目：

树链剖分专题
给定数组father，大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
给定数组values，大小为N，values[i]=v表示节点i的权值是v
实现如下4个方法，保证4个方法都很快！
1)让某个子树所有节点值加上v，入参：int head, int v
2)查询某个子树所有节点值的累加和，入参：int head
3)在树上从a到b的整条链上所有加上v，入参：int a, int b, int v
4)查询在树上从a到b的整条链上所有节点值的累加和，入参：int a, int b



22 大厂高频算法和数据结构面试题22

题目：

给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。每个子数组的长度为k，我们要使这3*k个项的和最大化。返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。
Leetcode题目：https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
Leetcode题目：https://leetcode.com/problems/trapping-rain-water/

给你一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度，请计算图中形状最多能接多少体积的雨水。
Leetcode题目：https://leetcode.com/problems/trapping-rain-water-ii/

一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度
比如， {3,1,2,4,5}、{4,5,3,1,2}或{1,2,4,5,3}都代表同样结构的环形山
山峰A和山峰B能够相互看见的条件为: 
1.如果A和B是同一座山，认为不能相互看见
2.如果A和B是不同的山，并且在环中相邻，认为可以相互看见
3.如果A和B是不同的山，并且在环中不相邻，假设两座山高度的最小值为min
       1)如果A通过顺时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
       2)如果A通过逆时针方向到B的途中没有高度比min大的山峰，认为A和B可以相互看见
两个方向只要有一个能看见，就算A和B可以相互看见
给定一个不含有负数且没有重复值的数组 arr，请返回有多少对山峰能够相互看见
进阶，给定一个不含有负数但可能含有重复值的数组arr，返回有多少对山峰能够相互看见

你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。
你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。
返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。
Leetcode题目：https://leetcode.com/problems/tallest-billboard/



23 大厂高频算法和数据结构面试题23

题目：

给定数组father大小为N，表示一共有N个节点
father[i] = j 表示点i的父亲是点j， father表示的树一定是一棵树而不是森林
queries是二维数组，大小为M*2，每一个长度为2的数组都表示一条查询
[4,9], 表示想查询4和9之间的最低公共祖先… 
[3,7], 表示想查询3和7之间的最低公共祖先…
tree和queries里面的所有值，都一定在0~N-1之间
返回一个数组ans，大小为M，ans[i]表示第i条查询的答案

给定一个数组arr，长度为N > 1，从中间切一刀，保证左部分和右部分都有数字，一共有N-1种切法
如此多的切法中，每一种都有:绝对值(左部分最大值 – 右部分最大值)，返回最大的绝对值是多少

定义什么是可整合数组：一个数组排完序之后，除了最左侧的数外，有arr[i] = arr[i-1]+1
则称这个数组为可整合数组比如{5,1,2,4,3}、{6,2,3,1,5,4}都是可整合数组，返回arr中最长可整合子数组的长度

超级水王问题
给定一个数组arr，长度为N，如果某个数出现次数大于N/2，称该数为水王数，如果arr中有水王数，打印这个数；如果没有水王数，打印没有水王数
要求时间复杂度O(N)，额外空间复杂度O(1)
扩展1：摩尔投票
扩展2：给定一个正数K，返回所有出现次数>N/K的数

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。
找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。
Leetcode题目：https://leetcode.com/problems/minimum-cost-to-merge-stones/



24 大厂高频算法和数据结构面试题24

题目：

给定一个正数数组arr，长度一定大于6（>=7），一定要选3个数字做分割点，从而分出4个部分，并且每部分都有数
分割点的数字直接删除，不属于任何4个部分中的任何一个。返回有没有可能分出的4个部分累加和一样大
如：{3,2,3,7,4,4,3,1,1,6,7,1,5,2}。可以分成{3,2,3}、{4,4}、{1,1,6}、{1,5,2}。分割点是不算的！

长度为N的数组arr，一定可以组成N^2个数字对。例如arr = [3,1,2]，数字对有(3,3) (3,1) (3,2) (1,3) (1,1) (1,2) (2,3) (2,1) (2,2)
也就是任意两个数都可以，而且自己和自己也算数字对。数字对怎么排序？第一维数据从小到大；第一维数据一样的，第二维数组也从小到大
所以上面的数值对排序的结果为：(1,1)(1,2)(1,3)(2,1)(2,2)(2,3)(3,1)(3,2)(3,3)。给定一个数组arr，和整数k，返回第k小的数值对

正常的里程表会依次显示自然数表示里程
吉祥的里程表会忽略含有4的数字而跳到下一个完全不含有4的数
正常：1 2 3 4 5 6 7 8  9 10 11 12 13 14 15
吉祥：1 2 3 5 6 7 8 9 10 11 12 13 15 16 17 ... 38 39 50 51 52 53 55
给定一个吉祥里程表的数字num(当然这个数字中不含有4)
返回这个数字代表的真实里程

N * M的棋盘（N和M是输入参数），每种颜色的格子数必须相同的，上下左右的格子算相邻，相邻格子染的颜色必须不同，所有格子必须染色，返回至少多少种颜色可以完成任务

给定两个字符串str1和str2，在str1中寻找一个最短子串，能包含str2的所有字符，字符顺序无所谓，str1的这个最短子串也可以包含多余的字符，返回这个最短包含子串

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）
Leetcode题目：https://leetcode.com/problems/remove-duplicate-letters/



25 大厂高频算法和数据结构面试题25

题目：

An IP address is a formatted 32-bit unsigned integer where each group of 8 bits is printed as a decimal number and the dot character '.' splits the groups.
For example, the binary number 00001111 10001000 11111111 01101011 (spaces added for clarity) formatted as an IP address would be "15.136.255.107".
A CIDR block is a format used to denote a specific set of IP addresses. It is a string consisting of a base IP address, followed by a slash, followed by a prefix length k.
The addresses it covers are all the IPs whose first k bits are the same as the base IP address.
For example, "123.45.67.89/20" is a CIDR block with a prefix length of 20. Any IP address whose binary representation matches
01111011 00101101 0100xxxx xxxxxxxx, where x can be either 0 or 1, is in the set covered by the CIDR block.
You are given a start IP address ip and the number of IP addresses we need to cover n. 
Your goal is to use as few CIDR blocks as possible to cover all the IP addresses in the inclusive range [ip, ip + n - 1] exactly
No other IP addresses outside of the range should be covered.
Return the shortest list of CIDR blocks that covers the range of IP addresses. If there are multiple answers, return any of them.
Leetcode题目：https://leetcode.com/problems/ip-to-cidr/

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组
注意：答案中不可以包含重复的三元组
Leetcode题目：https://leetcode.com/problems/3sum/

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
Leetcode题目：https://leetcode.com/problems/max-points-on-a-line/

良好加油站问题最优解
Leetcode题目：https://leetcode.com/problems/gas-station/



26 大厂高频算法和数据结构面试题26

题目：

有三个有序数组，分别在三个数组中挑出3个数，x、y、z。返回 |x-y| + |y-z| + |z-x|最小是多少？
Leetcode题目：https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词
单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格
同一个单元格内的字母在一个单词中不允许被重复使用。
Leetcode题目：https://leetcode.com/problems/word-search-ii/

给定一个仅包含数字 0-9 的字符串和一个目标值，在数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。
输入: num = "123", target = 6
输出: ["1+2+3", "1*2*3"] 
示例 2:
输入: num = "232", target = 8
输出: ["2*3+2", "2+3*2"]
示例 3:
输入: num = "105", target = 5
输出: ["1*0+5","10-5"]
示例 4:
输入: num = "00", target = 0
输出: ["0+0", "0-0", "0*0"]
Leetcode题目：https://leetcode.com/problems/expression-add-operators/

按字典 wordList 完成从单词 beginWord 到单词 endWord 转化，一个表示此过程的 转换序列 是形式上像 beginWord -> s1 -> s2 -> ... -> sk 这样的单词序列，并满足：
每对相邻的单词之间仅有单个字母不同。
转换过程中的每个单词 si（1 <= i <= k）必须是字典 wordList 中的单词。注意，beginWord 不必是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord ，以及一个字典 wordList
请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列 ，如果不存在这样的转换序列，返回一个空列表
每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回
Leetcode题目：https://leetcode.com/problems/word-ladder-ii/



27 大厂高频算法和数据结构面试题27

题目：

每一个项目都有三个数，[a,b,c]表示这个项目a和b乐队参演，花费为c
每一个乐队可能在多个项目里都出现了，但是只能被挑一次
nums是可以挑选的项目数量，所以一定会有nums*2只乐队被挑选出来
返回一共挑nums轮(也就意味着一定请到所有的乐队)，最少花费是多少？
如果怎么都无法在nums轮请到nums*2只乐队且每只乐队只能被挑一次，返回-1
nums<9，programs长度小于500，每组测试乐队的全部数量一定是nums*2，且标号一定是0 ~ nums*2-1

企鹅厂每年都会发文化衫，文化衫有很多种，厂庆的时候，企鹅们都需要穿文化衫来拍照
一次采访中，记者随机遇到的企鹅，企鹅会告诉记者还有多少企鹅跟他穿一种文化衫
我们将这些回答放在answers数组里，返回鹅厂中企鹅的最少数量
Leetcode题目：https://leetcode.com/problems/rabbits-in-forest/

给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标
你可以假设每种输入只会对应一个答案。但是数组中同一个元素在答案里不能重复出现，你可以按任意顺序返回答案
Leetcode题目：https://leetcode.com/problems/two-sum/

给你一个32位的有符号整数x，返回将x中的数字部分反转后的结果，如果反转后整数超过 32 位的有符号整数的范围，就返回0
假设环境不允许存储 64 位整数（有符号或无符号）
Leetcode题目：https://leetcode.com/problems/reverse-integer/



28 大厂高频算法和数据结构面试题28

题目：

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）
函数 myAtoi(string s) 的算法如下：
读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为231 − 1。
返回整数作为最终结果。
注意：本题中的空白字符只包括空格字符 ' ' 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。
Leetcode题目：https://leetcode.com/problems/string-to-integer-atoi/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字
Leetcode题目：https://leetcode.com/problems/integer-to-roman/

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 
同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
Leetcode题目：https://leetcode.com/problems/roman-to-integer/

编写一个函数来查找字符串数组中的最长公共前缀，如果不存在公共前缀，返回空字符串 ""。
Leetcode题目：https://leetcode.com/problems/longest-common-prefix/

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
按键2对应：'a', 'b', 'c'
按键3对应：'d', 'e', 'f'
按键4对应：'g', 'h', 'i'
按键5对应：'j', 'k', 'l'
按键6对应：'m', 'n', 'o'
按键7对应：'p', 'q', 'r', 's'
按键8对应：'t', 'u', 'v'
按键9对应：'w', 'x', 'y', 'z'
示例 1：
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：
输入：digits = ""
输出：[]
示例 3：
输入：digits = "2"
输出：["a","b","c"]
Leetcode题目：https://leetcode.com/problems/letter-combinations-of-a-phone-number/

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
Leetcode题目：https://leetcode.com/problems/remove-nth-node-from-end-of-list/

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
Leetcode题目：https://leetcode.com/problems/valid-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。
示例 1：
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
示例 2：
输入：n = 1
输出：["()"]
Leetcode题目：https://leetcode.com/problems/generate-parentheses/

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
示例 1：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
示例 2：
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4,_,_,_,_,_]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
Leetcode题目：https://leetcode.com/problems/remove-duplicates-from-sorted-array/

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
要求：设计并实现时间复杂度为 O(log n) 的算法
Leetcode题目：https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。
注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
Leetcode题目：https://leetcode.com/problems/valid-sudoku/

编写一个程序，通过填充空格来解决数独问题。
数独的解法需遵循如下规则：
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次
数独部分空格内已填入了数字，空白格用 '.' 表示。
Leetcode题目：https://leetcode.com/problems/sudoku-solver/

给定一个正整数 n ，输出的第 n 项。
前五项如下：
1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
返回第N项的字符串
Leetcode题目：https://leetcode.com/problems/count-and-say/

给定一个字符串数组，将字母异位词组合在一起。可以按任意顺序返回结果列表。
字母异位词指字母相同，但排列不同的字符串。
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
示例 2:
输入: strs = [""]
输出: [[""]]
示例 3:
输入: strs = ["a"]
输出: [["a"]]
Leetcode题目：https://leetcode.com/problems/group-anagrams/



29 大厂高频算法和数据结构面试题29

题目：

整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，
使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数
例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。
Leetcode题目：https://leetcode.com/problems/search-in-rotated-sorted-array/

实现 pow(x, n) ，即计算 x 的 n 次幂函数
Leetcode题目：https://leetcode.com/problems/powx-n/

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]
请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间
Leetcode题目：https://leetcode.com/problems/merge-intervals/

一个机器人位于一个 m x n 网格的左上角
机器人每次只能向下或者向右移动一步
机器人试图达到网格的右下角
问总共有多少条不同的路径？
Leetcode题目：https://leetcode.com/problems/unique-paths/

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加1
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字
你可以假设除了整数 0 之外，这个整数不会以零开头
示例 1：
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：
输入：digits = [9,9,9]
输出：[1,0,0,0]
解释：输入数组表示数字 1000。
示例 3：
输入：digits = [0]
输出：[1]
Leetcode题目：https://leetcode.com/problems/plus-one/

实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4
输出: 2
示例 2:
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。
Leetcode题目：https://leetcode.com/problems/sqrtx/

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
进阶：
一个直观的解决方案是使用 O(m * n) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？
Leetcode题目：https://leetcode.com/problems/set-matrix-zeroes/



30 大厂高频算法和数据结构面试题30

题目：

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
Leetcode题目 : https://leetcode.com/problems/word-search/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。
初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。
示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
Leetcode题目 : https://leetcode.com/problems/merge-sorted-array/

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
Leetcode题目 : https://leetcode.com/problems/decode-ways/

一条包含字母 A-Z 的消息通过以下的方式进行了编码：
'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。
给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。
同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）
示例 1 :
输入: "*"
输出: 9
解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
示例 2 :
输入: "1*"
输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
Leetcode题目 : https://leetcode.com/problems/decode-ways-ii/

给定一个二叉树，判断其是否是一个有效的二叉搜索树。
Leetcode题目 : https://leetcode.com/problems/validate-binary-search-tree/

给定一个二叉树，检查它是否是镜像对称的。
Leetcode题目 : https://leetcode.com/problems/symmetric-tree/

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
Leetcode题目 : https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
高度平衡二叉树是一棵满足每个节点的左右两个子树的高度差的绝对值不超过1的二叉树
Leetcode题目 : https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
进阶：
这棵树如果是普通二叉树，该怎么做。
你只能使用常量级额外空间。
Leetcode题目 : https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
Leetcode题目 : https://leetcode.com/problems/pascals-triangle/

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
你可以优化你的算法到 O(1) 空间复杂度吗？
Leetcode题目 : https://leetcode.com/problems/pascals-triangle-ii/

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和。
进阶：
如果返回最大路径和上的所有节点，该怎么做？
Leetcode题目 : https://leetcode.com/problems/binary-tree-maximum-path-sum/



31 大厂高频算法和数据结构面试题31

题目：

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
示例 2:
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
Leetcode题目 : https://leetcode.com/problems/valid-palindrome/

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord
序列中最后一个单词是 endWord
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。
Leetcode题目 : https://leetcode.com/problems/word-ladder/

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
Leetcode题目 : https://leetcode.com/problems/surrounded-regions/

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
Leetcode题目 : https://leetcode.com/problems/word-break/
Lintcode题目 : https://www.lintcode.com/problem/107/

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。
示例 1：
输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：
输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
示例 3：
输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]
Leetcode题目 : https://leetcode.com/problems/word-break-ii/

给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表头节点。
进阶：你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
Leetcode题目 : https://leetcode.com/problems/sort-list/

根据 逆波兰表示法，求表达式的值。
有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
说明：整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
示例 1：
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
Leetcode题目 : https://leetcode.com/problems/evaluate-reverse-polish-notation/



32 大厂高频算法和数据结构面试题32

题目：

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
Leetcode题目 : https://leetcode.com/problems/maximum-product-subarray/

给定一个有序无重复的数组nums， 和两个整数lower和upper， 返回[lower,upper]上所有缺失的数字段
示例1:
nums = [0,1,3,50,75], lower = 0, upper = 99
输出:["2","4->49","51->74","76->99"]
示例2:
nums = [], lower = 1, upper = 1
输出: ["1"]
示例3:
nums = [], lower = -3, upper = -1
输出： ["-3->-1"]
示例4:
nums = [-1], lower = -1, upper = -1
输出: []
示例5: 
nums = [-1], lower = -2, upper = -1
输出: ["-2"]
Leetcode题目 : https://leetcode.com/problems/missing-ranges/

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1：
输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：
输入：numerator = 2, denominator = 1
输出："2"
示例 3：
输入：numerator = 2, denominator = 3
输出："0.(6)"
示例 4：
输入：numerator = 4, denominator = 333
输出："0.(012)"
示例 5：
输入：numerator = 1, denominator = 5
输出："0.2"
Leetcode题目 : https://leetcode.com/problems/fraction-to-recurring-decimal/

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。
例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
示例 1:
输入: columnTitle = "A"
输出: 1
示例 2:
输入: columnTitle = "AB"
输出: 28
示例 3:
输入: columnTitle = "ZY"
输出: 701
示例 4:
输入: columnTitle = "FXSHRXW"
输出: 2147483647
Leetcode题目 : https://leetcode.com/problems/excel-sheet-column-number/

给定一个整数 n，返回 n! 结果尾数中零的数量。
示例 1:
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。
Leetcode题目 : https://leetcode.com/problems/factorial-trailing-zeroes/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
进阶：
尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
Leetcode题目 : https://leetcode.com/problems/rotate-array/

颠倒给定的 32 位无符号整数的二进制位。
进阶:
如果多次调用这个函数，你将如何优化你的算法？
示例 1：
输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：
输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
Leetcode题目 : https://leetcode.com/problems/reverse-bits/

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
提示：
输入必须是长度为 32 的 二进制串 。
进阶：
如果多次调用这个函数，你将如何优化你的算法？
Leetcode题目 : https://leetcode.com/problems/number-of-1-bits/

编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
示例 2：
输入：n = 2
输出：false
提示：
1 <= n <= 2^31 - 1
Leetcode题目 : https://leetcode.com/problems/happy-number

统计所有小于非负整数 n 的质数的数量。
示例 1：
输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：
输入：n = 0
输出：0
示例 3：
输入：n = 1
输出：0
提示：
0 <= n <= 5 * 10^6
Leetcode题目 : https://leetcode.com/problems/count-primes/

拼多多笔试题 : 给定一个数组arr，arr[i] = j，表示第i号试题的难度为j。给定一个非负数M
想出一张卷子，对于任何相邻的两道题目，前一题的难度不能超过后一题的难度+M
返回所有可能的卷子种数



33 大厂高频算法和数据结构面试题33

题目：

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。
例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
示例 1：
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
示例 2：
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
Leetcode题目 : https://leetcode.com/problems/course-schedule/

现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
示例 1:
输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:
输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
Leetcode题目 : https://leetcode.com/problems/course-schedule-ii/

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。
这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。
给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。
示例 1：
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
示例 2：
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 3：
输入：nums = [0]
输出：0
Leetcode题目 : https://leetcode.com/problems/house-robber-ii/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。
Leetcode题目 : https://leetcode.com/problems/delete-node-in-a-linked-list/

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4]
输出: [24,12,8,6]
说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
Leetcode题目 : https://leetcode.com/problems/product-of-array-except-self/

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true
示例 2:
输入: s = "rat", t = "car"
输出: false
Leetcode题目 : https://leetcode.com/problems/valid-anagram/

给定一个二维数组，实现二维数组的迭代器，包含hasNext()和next()两个迭代器常见方法。
Leetcode题目 : https://leetcode.com/problems/flatten-2d-vector/

出版社印发了一个名单，名单上的每一行都是一个字符串，字符串都是小写字母，但是字符串出现的先后顺序和日常的字典序不一样
现在怀疑出版社内部对于字符有自己的字典序规则，请根据字符串之间出现的顺序，返回可能存在的、出版社内部的字符顺序
如果从名单来看不存在这样的字符顺序，返回空字符串
Leetcode题目 : https://leetcode.com/problems/alien-dictionary/

给定一个数n，所有人的编号从0到n-1
给定一个函数 boolean know(int i, int j)，该函数表示i这个人认不认识j这个人，认识关系是单向的
有了这个函数，你可以检查认识这件事情。
规定何为明星？1）所有人都认识这个人。2）这个人不认识自己之外的所有人。那么这个人就是明星
利用know函数，找到明星，返回明星的编号，如果没有明星返回-1。
Leetcode题目 : https://leetcode.com/problems/find-the-celebrity/

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1：
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：
输入：n = 13
输出：2
解释：13 = 4 + 9
Leetcode题目 : https://leetcode.com/problems/perfect-squares/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:
必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。
Leetcode题目 : https://leetcode.com/problems/move-zeroes/



34 大厂高频算法和数据结构面试题34

题目：

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。
你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。
Leetcode题目 : https://leetcode.com/problems/find-the-duplicate-number/

生命游戏，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。
给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。
每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：
如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。
Leetcode题目 : https://leetcode.com/problems/game-of-life/

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。
例如，
[2,3,4] 的中位数是 3
[2,3] 的中位数是 (2 + 3) / 2 = 2.5
设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
Leetcode题目 : https://leetcode.com/problems/find-median-from-data-stream/

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。
示例：
输入：nums = [5,2,6,1]
输出：[2,1,1,0] 
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧仅有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
Leetcode题目 : https://leetcode.com/problems/count-of-smaller-numbers-after-self/

给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。
你可以假设所有输入数组都可以得到满足题目要求的结果。
示例 1：
输入：nums = [1,5,1,1,6,4]
输出：[1,6,1,5,1,4]
解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。
示例 2：
输入：nums = [1,3,2,2,3,1]
输出：[2,3,1,3,1,2]
进阶：你能用 O(n) 时间复杂度和原地 O(1) 额外空间来实现吗？
Leetcode题目 : https://leetcode.com/problems/wiggle-sort-ii/

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
Leetcode题目 : https://leetcode.com/problems/power-of-three/

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。
请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。
示例 1:
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
示例 2:
输入: 2->1->3->5->6->4->7->NULL 
输出: 2->3->6->7->1->5->4->NULL
说明:
应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。
Leetcode题目 : https://leetcode.com/problems/odd-even-linked-list/

给定一个字符串str，和一个正数k，返回字符种类不超过k种的最长子串长度。
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/

给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；
该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。
实现扁平迭代器类 NestedIterator ：
NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。
int next() 返回嵌套列表的下一个整数。
boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。
你的代码将会用下述伪代码检测：
initialize iterator with nestedList
res = []
while iterator.hasNext()
    append iterator.next() to the end of res
return res
如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。
示例 1：
输入：nestedList = [[1,1],2,[1,1]]
输出：[1,1,2,1,1]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。
示例 2：
输入：nestedList = [1,[4,[6]]]
输出：[1,4,6]
解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。
Leetcode题目 : https://leetcode.com/problems/flatten-nested-list-iterator/

tic-tac-toe游戏，不知道的同学可以自行搜索。请实现以下类TicTacToe。
构造方法：TicTacToe(int n) : TicTacToe游戏的类，n表示目前在n*n的棋盘上玩游戏。
内部方法：int move(int i, int j, int p) : p只可能是1和2，表示玩家1还是玩家2。当前玩家在i行j列上走了一步。返回值只可能是0、1、2，0表示没有玩家赢；1表示玩家1赢了；2表示玩家2赢了。
Leetcode题目 : https://leetcode.com/problems/design-tic-tac-toe/

设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。
insert(val)：当元素 val 不存在时，向集合中插入该项。
remove(val)：元素 val 存在时，从集合中移除该项。
getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。
Leetcode题目 : https://leetcode.com/problems/insert-delete-getrandom-o1/

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。
实现 Solution class:
Solution(int[] nums) 使用整数数组 nums 初始化对象
int[] reset() 重设数组到它的初始状态并返回
int[] shuffle() 返回数组随机打乱后的结果
Leetcode题目 : https://leetcode.com/problems/shuffle-an-array/



35 大厂高频算法和数据结构面试题35

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
示例 1:
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:
输入: nums = [1], k = 1
输出: [1]
提示：
1 <= nums.length <= 10^5
k 的取值范围是 [1, 数组中不相同的元素的个数]
题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。
Leetcode题目 : https://leetcode.com/problems/top-k-frequent-elements/

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。
示例 1：
输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：
输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。
提示：
1 <= s.length <= 10^4
s 仅由小写英文字母组成
Leetcode题目 : https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/

写一个程序，输出从 1 到 n 数字的字符串表示。
1. 如果 n 是3的倍数，输出“Fizz”；
2. 如果 n 是5的倍数，输出“Buzz”；
3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。
示例：
n = 15,
返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
Leetcode题目 : https://leetcode.com/problems/fizz-buzz/

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。
为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。
例如:
输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
输出:
2
解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
Leetcode题目 : https://leetcode.com/problems/4sum-ii/

给定一个未排序的整数数组，找到最长递增子序列的个数。
示例 1:
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
Leetcode题目 : https://leetcode.com/problems/number-of-longest-increasing-subsequence/

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。
注意：两个节点之间的路径长度由它们之间的边数表示。
注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。
Leetcode题目 : https://leetcode.com/problems/longest-univalue-path/

来自真实笔试
给定一个长度len，表示一共有几位
所有字符都是小写(a~z)，可以生成长度为1，长度为2，
长度为3...长度为len的所有字符串
如果把所有字符串根据字典序排序，每个字符串都有所在的位置。
给定一个字符串str，给定len，请返回str是总序列中的第几个
比如len = 4，字典序的前几个字符串为:
a aa aaa aaaa aaab ... aaaz ... azzz b ba baa baaa ... bzzz c ...
a是这个序列中的第1个，bzzz是这个序列中的第36558个

来自小红书
[0,4,7] ： 0表示这里石头没有颜色，如果变红代价是4，如果变蓝代价是7
[1,X,X] ： 1表示这里石头已经是红，而且不能改颜色，所以后两个数X无意义
[2,X,X] ： 2表示这里石头已经是蓝，而且不能改颜色，所以后两个数X无意义
颜色只可能是0、1、2，代价一定>=0
给你一批这样的小数组，要求最后必须所有石头都有颜色，且红色和蓝色一样多，返回最小代价
如果怎么都无法做到所有石头都有颜色、且红色和蓝色一样多，返回-1

来自小红书
一场电影开始和结束时间可以用一个小数组来表示["07:30","12:00"]
已知有2000场电影开始和结束都在同一天，这一天从00:00开始到23:59结束
一定要选3场完全不冲突的电影来观看，返回最大的观影时间
如果无法选出3场完全不冲突的电影来观看，返回-1

来自网易
map[i][j] == 0，代表(i,j)是海洋，渡过的话代价是2
map[i][j] == 1，代表(i,j)是陆地，渡过的话代价是1
map[i][j] == 2，代表(i,j)是障碍，无法渡过
每一步上、下、左、右都能走，返回从左上角走到右下角最小代价是多少，如果无法到达返回-1

来自网易
给定一个正数数组arr，表示每个小朋友的得分
任何两个相邻的小朋友，如果得分一样，怎么分糖果无所谓，但如果得分不一样，分数大的一定要比分数少的多拿一些糖果
假设所有的小朋友坐成一个环形，返回在不破坏上一条规则的情况下，需要的最少糖果数



36 大厂高频算法和数据结构面试题36

来自网易
规定：L[1]对应a，L[2]对应b，L[3]对应c，...，L[25]对应y
S1 = a
S(i) = S(i-1) + L[i] + reverse(invert(S(i-1)));
解释invert操作：
S1 = a
S2 = aby
假设invert(S(2)) = 甲乙丙
a + 甲 = 26, 那么 甲 = 26 - 1 = 25 -> y
b + 乙 = 26, 那么 乙 = 26 - 2 = 24 -> x
y + 丙 = 26, 那么 丙 = 26 - 25 = 1 -> a
如上就是每一位的计算方式，所以invert(S2) = yxa
所以S3 = S2 + L[3] + reverse(invert(S2)) = aby + c + axy = abycaxy
invert(abycaxy) = yxawyba, 再reverse = abywaxy
所以S4 = abycaxy + d + abywaxy = abycaxydabywaxy
直到S25结束
给定两个参数n和k，返回Sn的第k位是什么字符，n从1开始，k从1开始
比如n=4，k=2，表示S4的第2个字符是什么，返回b字符
 
来自京东
把一个01字符串切成多个部分，要求每一部分的0和1比例一样，同时要求尽可能多的划分
比如 : 01010101
01 01 01 01 这是一种切法，0和1比例为 1 : 1
0101 0101 也是一种切法，0和1比例为 1 : 1
两种切法都符合要求，但是那么尽可能多的划分为第一种切法，部分数为4
比如 : 00001111
只有一种切法就是00001111整体作为一块，那么尽可能多的划分，部分数为1
给定一个01字符串str，假设长度为N，要求返回一个长度为N的数组ans
其中ans[i] = str[0...i]这个前缀串，要求每一部分的0和1比例一样，同时要求尽可能多的划分下，部分数是多少
输入: str = "010100001"
输出: ans = [1, 1, 1, 2, 1, 2, 1, 1, 3]
 
来自美团
给定两个字符串s1和s2
返回在s1中有多少个子串等于s2
 
来自美团
() 分值为2
(()) 分值为3
((())) 分值为4
也就是说，每包裹一层，分数就是里面的分值+1
()() 分值为2 * 2
(())() 分值为3 * 2
也就是说，每连接一段，分数就是各部分相乘，以下是一个结合起来的例子
(()())()(()) -> (2 * 2 + 1) * 2 * 3 -> 30
给定一个括号字符串str，已知str一定是正确的括号结合，不会有违规嵌套
返回分数
 
来自美团
给定一个数组arr，长度为N，做出一个结构，可以高效的做如下的查询
1) int querySum(L,R) : 查询arr[L...R]上的累加和
2) int queryAim(L,R) : 查询arr[L...R]上的目标值，目标值定义如下：
       假设arr[L...R]上的值为[a,b,c,d]，a+b+c+d = s
       目标值为 : (s-a)^2 + (s-b)^2 + (s-c)^2 + (s-d)^2
3) int queryMax(L,R) : 查询arr[L...R]上的最大值
要求：
1) 初始化该结构的时间复杂度不能超过O(N*logN)
2) 三个查询的时间复杂度不能超过O(logN)
3) 查询时，认为arr的下标从1开始，比如 : 
   arr = [ 1, 1, 2, 3 ];
   querySum(1, 3) -> 4
   queryAim(2, 4) -> 50
   queryMax(1, 4) -> 3

来自美团
有一棵树，给定头节点h，和结构数组m，下标0弃而不用
比如h = 1, m = [ [] , [2,3], [4], [5,6], [], [], []]
表示1的孩子是2、3; 2的孩子是4; 3的孩子是5、6; 4、5和6是叶节点，都不再有孩子
每一个节点都有颜色，记录在c数组里，比如c[i] = 4, 表示节点i的颜色为4
一开始只有叶节点是有权值的，记录在w数组里，
比如，如果一开始就有w[i] = 3, 表示节点i是叶节点、且权值是3
现在规定非叶节点i的权值计算方式：
根据i的所有直接孩子来计算，假设i的所有直接孩子，颜色只有a,b,k
w[i] = Max {
             (颜色为a的所有孩子个数 + 颜色为a的孩子权值之和), 
             (颜色为b的所有孩子个数 + 颜色为b的孩子权值之和),
             (颜色为k的所有孩子个数 + 颜色k的孩子权值之和)
           }
请计算所有孩子的权值并返回
 
来自腾讯
给定一个单链表的头节点head，每个节点都有value(>0)，给定一个正数m
value%m的值一样的节点算一类
请把所有的类根据单链表的方式重新连接好，返回每一类的头节点
 
来自腾讯
给定一个数组arr，当拿走某个数a的时候，其他所有的数都+a
请返回最终所有数都拿走的最大分数
比如: [2,3,1]
当拿走3时，获得3分，数组变成[5,4]
当拿走5时，获得5分，数组变成[9]
当拿走9时，获得9分，数组变成[]
这是最大的拿取方式，返回总分17
 
来自腾讯
给定一个正数数组arr，代表每个人的体重。给定一个正数limit代表船的载重，所有船都是同样的载重量
每个人的体重都一定不大于船的载重
要求：
1, 可以1个人单独一搜船
2, 一艘船如果坐2人，两个人的体重相加需要是偶数，且总体重不能超过船的载重
3, 一艘船最多坐2人
返回如果想所有人同时坐船，船的最小数量
 
来自腾讯
给定一个字符串str，和一个正数k
返回长度为k的所有子序列中，字典序最大的子序列
 
来自哈喽单车(Leetcode原题)
Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。
一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。
如果石子堆里没有石子了，则无法操作的玩家输掉游戏。
给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。
leetcode原题 : https://leetcode.com/problems/stone-game-iv/

来自三七互娱(Leetcode原题)
给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
Leetcode原题 : https://leetcode.com/problems/bus-routes/



